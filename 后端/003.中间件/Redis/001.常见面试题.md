---
date: 2024-08-30 13:47
modified: 2024-08-30 21:34
---

# 认识 Redis

## 什么是 Redis？

Redis 是一种==基于内存==的数据库，对数据的读写操作都是在内存中完成，因此==读写速度非常快==，常用于==缓存，消息队列、分布式锁==等场景

Redis 提供了==多种数据类型==来支持不同的业务场景，比如 String（字符串）、Hash（哈希）、List （列表）、Set（集合）、Zset（有序集合）、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是==原子性==的，因为执行命令由单线程负责，不存在并发竞争的问题

除此之外，Redis 还支持==事务、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制==等

## Redis 和 Memcached 有什么区别？

Memcached 也是基于内存的数据库

共同点：

1. 都是基于内存的数据库，性能都非常高，一般都用来当做缓存使用
2. 都有过期策略

区别：

- 支持的数据类型：
	- Redis 支持的数据类型更丰富
	- Memcached 只支持 key-value 数据类型
- 数据持久化：
	- Redis 支持数据持久化，可以将内存中的数据保持在磁盘中，重启时可以再次加载进行使用
	- Memcached 没有持久化功能，数据全部存在内存之中，重启或者挂掉后，数据就没了
- 集群：
	- Redis 原生支持集群模式
	- Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据
- 其他：
	- Redis 支持发布订阅模型、Lua 脚本、事务等功能
	- Memcached 不支持

## 为什么用 Redis 作为 MySQL 的缓存？

主要是因为 Redis 具备「==高性能==」和「==高并发==」两种特性

1. 高性能
	- 用户第一次访问 MySQL 中的数据会比较慢，因为是从硬盘读取
	- 之后访问相同的数据缓存在 Redis 中，直接操作内存，速度相当快
	- 如果修改数据需要同时修改 Redis 和 MySQL 两个地方，会有==双写一致性==的问题
2. 高并发
	- 单台设备 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w
	- 直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，所以可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存而不经过数据库

# Redis 数据结构

## Redis 数据类型以及使用场景分别是什么？

Redis 提供了丰富的数据类型，常见的有 5 种：

| 结构类型        | 结构储存的值                            | 结构的读写能力                                        | 常见应用场景                                            |
| ----------- | --------------------------------- | ---------------------------------------------- | ------------------------------------------------- |
| String（字符串） | 字符串、整数、浮点数                        | 对整个字符串或字符串的一部分进行操作；对整数和浮点数进行自增或自减操作            | 缓存对象、常规计数、分布式锁、共享 session 信息                      |
| List（列表）    | 一个链表，每个节点包含一个字符串                  | 对链表两端惊喜 push 和 pop 操作；根据索引读取单个或多个元素；根据值查找或删除元素 | 消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据） |
| Set（集合）     | 包含字符串的无序集合                        | 添加、获取、删除、是否存在单个元素；计算交集、并集、差集等                  | 缓存对象、购物车                                          |
| Hash（哈希、散列） | 包含键值对的无序散列表                       | 添加、获取、删除、是否存在单个元素                              | 聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动                   |
| Zset（有序集合）  | 包含键值对的有序散列表，元素的排列顺序分数（浮点数类型）的大小决定 | 添加、获取、删除、是否存在单个元素；根据分数范围或成员来获取元素               | 排序场景，比如排行榜、电话和姓名排序                                |

Redis 后续版本又支持 4 种数据类型，它们的应用场景如下：

- BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；
- HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；
- GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；
- Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。

## 五种常见的 Redis 数据类型是怎么实现？

我画了一张 Redis 数据类型和底层数据结构的对应关图，左边是 Redis 3.0版本的，也就是《Redis 设计与实现》这本书讲解的版本，现在看还是有点过时了，右边是现在 Redis 7.0 版本的。
