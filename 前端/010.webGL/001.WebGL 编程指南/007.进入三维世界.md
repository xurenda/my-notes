---
date: 2024-08-20 20:49
modified: 2024-08-21 13:28
---

三维物体是由二维图形（特别是三角形）组成的

# 视点和视线

三维物体与二维图形的最显著区别就是，三维物体具有深度，也就是 Z 轴

但是，最后还是得把三维场景绘制到二维的屏幕上，即绘制观察者看到的世界。观察者：在什么地方、朝哪里看、视野有多宽、能看多远

- 将观察者所处的位置称为==视点==（eye point）
- 从视点出发沿着观察方向的射线称作==视线==（viewing direction）

本节将研究如何通过视点和视线来描述观察者，到下一节再来研究“观察者能看多远”的问题

## 视点、观察目标点和上方向

为了确定观察者的状态，需要获取三项信息：

- 视点，即观察者的位置
	- 视点坐标用 (eyeX, eyeY, eyeZ) 表示
- 观察目标点（look-at point），即被观察目标所在的点，可以用来确定视线
	- 注意，观察目标点是一个点，而不是视线方向，只有同时知道观察目标点和视点，才能算出视线方向
	- 观察目标点的坐标用 (atX, atY, atZ) 表示
- 上方向（up direction），即最终绘制在屏幕上的影像中的向上的方向
	- 上方向是具有 3 个分量的矢量，用 (upX, upY, upZ) 表示

![[Pasted image 20240821111303.png]]

在 WebGL 中，可以用上述三个矢量创建一个==视图矩阵==（view matrix）用于表示观察者的状态，然后将该矩阵传给顶点着色器。之所以被称为视图矩阵，是因为它最终影响了显示在屏幕上的视图，也就是观察者观察到的场景

矩阵变换库 [[004.高级变换与动画基础#矩阵变换库：`cuon-matrix.js`|cuon-matrix.js]] 提供了方法可以根据上述三个矢量：视点、观察点、上方向，来创建出视图矩阵：`Matrix4.setLookAt(eyeX, eyeY, eyeZ, atX, atY, atZ, upX, upY, upZ)`，视图矩阵的类型是 `Matrix4`，其观察点映射到 `<canvas>` 的中心点

WebGL 系统中，观察者的默认状态：

- 视点处于原点 (0, 0, 0)
- 观察点为 (0, 0, 任意负值)，即视线为 Z 轴负方向（指向屏幕内部）
- 上方向 Y 轴正方向，即 (0, 1, 0)

## 使用视图矩阵

![[Pasted image 20240821120034.png]]

```js
// 顶点着色器程序（GLSL ES）
const vertexShaderSource = `
attribute vec4 a_Position;
attribute vec4 a_Color;
uniform mat4 u_ViewMatrix; // 视图矩阵
varying vec4 v_Color;
void main() {
  gl_Position = u_ViewMatrix * a_Position;
  v_Color = a_Color;
}
`

// 片元着色器程序（GLSL ES）
const fragmentShaderSource = `
precision mediump float;
varying vec4 v_Color;
void main() {
  gl_FragColor = v_Color;
}
`

// 获取 canvas 元素
// 获取 WebGL 上下文
// 初始化着色器

// 设置顶点坐标和颜色
const n = initVertexBuffers(gl)
if (n < 0) {
console.error('设置顶点位置失败')
return
}

// 获取 u_ViewMatrix uniform 变量
const u_ViewMatrix = gl.getUniformLocation(gl.program, 'u_ViewMatrix')
if (!u_ViewMatrix) {
console.error('获取 uniform 变量失败')
return
}

// 定义视图矩阵：视点、目标点（视线）、上方向
const viewMatrix = new Matrix4()
viewMatrix.setLookAt(0.2, 0.25, 0.25, 0, 0, 0, 0, 1, 0)

// 将视图矩阵传给 u_ViewMatrix
gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements)

// 设置清除颜色并清空 canvas
// 绘制图形（三角形）


/**
 * 创建缓冲区对象，并将多个顶点的数据保存在缓冲区中，然后将缓冲区传给顶点着色器
 */
function initVertexBuffers(gl) {
  // 点的个数
  const n = 9
  // 三个点的坐标和颜色信息
  const verticesColors = new Float32Array([
    // 顶点坐标和颜色 (x, y, z, r, g, b)
    0.0, 0.5, -0.4, 0.0, 1.0, 0.0, // 绿色三角形在最后面
    -0.5, -0.5, -0.4, 0.0, 1.0, 0.0,
    0.5, -0.5, -0.4, 0.0, 1.0, 0.0,

    0.0, 0.5, -0.2, 1.0, 0.0, 0.0, // 红色三角形在中间
    -0.5, -0.5, -0.2, 1.0, 0.0, 0.0,
    0.5, -0.5, -0.2, 1.0, 0.0, 0.0,

    0.0, 0.5, 0.0, 0.0, 0.0, 1.0, // 蓝色三角形在最前面
    -0.5, -0.5, 0.0, 0.0, 0.0, 1.0,
    0.5, -0.5, 0.0, 0.0, 0.0, 1.0,
  ])

  // 创建缓冲区对象
  // 将缓冲区对象绑定到目标
  // 向缓冲区对象中写入数据
  // 获取 attribute 变量的存储位置

  // 将缓冲区对象分配给 attribute 变量
  const FSIZE = verticesColors.BYTES_PER_ELEMENT
  gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 6, 0)
  gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, FSIZE * 6, FSIZE * 3)

  // 开启 attribute 变量与分配给它的缓冲区对象
}
```

可以看到这里的视图矩阵和之前的[[004.高级变换与动画基础#^mxjz|模型矩阵]]用法是一样的，都是 `<顶点坐标> = <视图/模型矩阵> × <原始顶点坐标>`

这是因为“改变观察者的状态”与“对整个世界进行模型变换”，本质上是一样的，比如：

![[Pasted image 20240821122000.png]]

为了“语义化”，区分了视图矩阵和模型矩阵，可以这样使用：`<顶点坐标> = <视图矩阵> × <模型矩阵> × <原始顶点坐标>`

因为矩阵相乘[[101.附录：本书涉及的数学知识#矢量和矩阵运算的性质|符合结合律]]，所以上式等同于 `<顶点坐标> = (<视图矩阵> × <模型矩阵>) × <原始顶点坐标>`，将 `<视图矩阵> × <模型矩阵>` 得到的矩阵称为==模型视图矩阵==（model view matrix）

## 利用键盘改变视点

```js
// 顶点着色器程序（GLSL ES）

// 片元着色器程序（GLSL ES）

// 获取 canvas 元素
// 获取 WebGL 上下文
// 初始化着色器
// 设置顶点坐标和颜色
// 获取 u_ViewMatrix uniform 变量
// 定义视图矩阵：视点、目标点（视线）、上方向
// 将视图矩阵传给 u_ViewMatrix
// 设置清除颜色并清空 canvas
// 绘制图形（三角形）

// 注册键盘事件
let eyeX = 0.2, eyeY = 0.25, eyeZ = 0.25
document.onkeydown = function (event) {
  switch (event.key) {
    case 'w':
    case 'ArrowUp':
      eyeY += 0.05
      break
    case 's':
    case 'ArrowDown':
      eyeY -= 0.05
      break
    case 'a':
    case 'ArrowLeft':
      eyeX -= 0.05
      break
    case 'd':
    case 'ArrowRight':
      eyeX += 0.05
      break
    case 'q':
      eyeZ -= 0.05
      break
    case 'e':
      eyeZ += 0.05
      break
    default:
      return
  }

  // 更新视图矩阵
  viewMatrix.setLookAt(eyeX, eyeY, eyeZ, 0, 0, 0, 0, 1, 0)
  // 将视图矩阵传给 u_ViewMatrix
  gl.uniformMatrix4fv(u_ViewMatrix, false, viewMatrix.elements)
  // 清空 canvas
  gl.clear(gl.COLOR_BUFFER_BIT)
  // 绘制图形（三角形）
  gl.drawArrays(gl.TRIANGLES, 0, n)
}
```

当视点移动时，三角形可能缺少一部分：

![[Pasted image 20240821124319.png]]

 这是因为没有指定可视范围（visible range），即实际观察得到的区域边界。WebGL 只显示可视范围内的区域。例中当改变视点位置时，三角形的一部分到了可视范围外，就缺了一个角

# 可视范围（正射类型）

虽然可以将三维物体放在三维空间中的任何地方，但是只有当它在可视范围内时，WebGL 才会绘制它。事实上，不绘制可视范围外的对象，是基本的降低程序开销的手段。绘制可视范围外的对象没有意义，即使把它们绘制出来也不会在屏幕上显示

可视范围在 WebGL 中称为可视空间（view volume），包括：

- 水平视角
- 垂直视角
- 可视深度

## 可视空间

有两类常用的可视空间：

- 长方体可视空间，也称盒状空间，由==正射投影==（orthographic projection）产生
- 四棱锥/金字塔可视空间，由==透视投影==（perspective projection）产生
