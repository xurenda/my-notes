---
date: 2024-08-19 18:00
modified: 2024-08-19 22:50
---

OpenGL ES 着色器语言（GLSL ES）是在 OpenGL 着色器语言（GLSL）的基础上，删除和简化一部分功能后形成的（好处是降低了硬件的功耗和性能开销），语法与 C 语言较为类似

WebGL 使用的 GLSL ES 版本是 1.00，但是请注意，WebGL 并不支持 GLSL ES 1.00 的所有特性，它支持的是 1.00 版本的一个子集，其中只包括 WebGL 需要的那些核心特性

# 基础

- 程序是大小写敏感的
- 每一个语句都应该以一个英文分号（`;`）结束
- 程序从 `main()` 函数开始执行, `main()` 函数无参数（`()`）、无返回值（`void`）
- 注释
	- 单行注释：`// 注释内容`
	- 多行注释：`/* 注释内容 */`

# 变量

- 只包括 `a-z`，`A-Z`，`0-9` 和下划线（`_`），数字不能开头
- 不能是关键字和保留字，但是你的变量名的一部分可以是它们
- 不能以 `gl_`、`webgl_` 或 `_webgl_` 开头，这些前缀已被保留

![[Pasted image 20240819182231.png]]

![[Pasted image 20240819182242.png]]

# 基本类型

- `int`：整型数，如：`-1`、`0`、`1`
- `float`：单精度浮点数，如：`1.0`、`-3.14159`
- `bool`：布尔值，`true` 或 `false`

只有这三种，没有字符串等

## GLSL ES 是强类型语言

- 变量在声明时就要确定类型，格式为 `<类型> <变量名>`，如：`vec4 a_Position`
- 函数必须指定参数类型和返回值类型，格式为 `<返回值类型> <函数名>(<参数类型> <形参名>, ...) {<函数体>}`，如：`void main() {}`
- 赋值操作（`=`）时，等号左右两侧的数据类型也必须一样

## 类型转换

- 转换为整型数
	- `int(float)`：将小数部分删去，如：`3.98` 转换为 `3`
	- `int(bool)`：`true` 转换为 `1`，`false` 转换为 `0`
- 转换为浮点数
	- `float(int)`：添加小数部分，如：`8` 转换为 `8.0`
	- `float(bool)`：`true` 转换为 `1.0`，`false` 转换为 `0.0`
- 转换为布尔值
	- `bool(int)`：`0` 转换为 `false`，其他转换为 `true`
	- `bool(float)`：`0.0` 转换为 `false`，其他转换为 `true`

## 运算符

![[Pasted image 20240819184324.png]]

# 矢量和矩阵

- 矢量
	- `vec2`、`vec3`、`vec4`：具有 2、3、4 个浮点数元素的矢量
	- `ivec2`、`ivec3`、`ivec4`：具有 2、3、4 个整型数元素的矢量
	- `bvec2`、`bvec3`、`bvec4`：具有 2、3、4 个布尔值元素的矢量
- 矩阵
	- `mat2`、`mat3`、`mat4`：2x2、3x3、4x4 的浮点数元素的矩阵（分别具有 4、9、16 个元素）

## 矢量构造函数

赋值语句左右类型必须相同（强类型语言）：

```glsl
vec4 a = 1.0; // 报错，赋值语句左右类型不符
```

GLSL ES 提供了丰富灵活的方式来创建矢量，可以传入数值和矢量：

```glsl
// 只传一个数值，就会使用这个数值填充矢量的每个分量
vec3 v3a = vec3(1.0); // (1.0, 1.0, 1.0)

// 传入正好数量的数值
vec3 v3b = vec3(1.0, 2.0, 3.0); // (1.0, 2.0, 3.0)

// 传入更多数量的数值，多出的数值会被丢弃
vec3 v3c = vec3(1.0, 2.0, 3.0, 4.0); // (1.0, 2.0, 3.0)

// 但是不能数量大于一，但不够，这样会报错
vec3 v3d = vec3(1.0, 2.0); // 报错

// 可以直接传入矢量，多出的分量会被丢弃，但是不能少，少了报错
vec2 v2 = vec2(v3b); // (1.0, 2.0)

// 可以传入多个矢量
vec4 v4a = vec4(v2, v3a); // (1.0, 2.0, 1.0, 1.0)

// 也可以矢量、数值混用
vec4 v4b = vec4(6.6, v2, 8.8); // (6.6, 1.0, 2.0, 8.8)
```
 
## 矩阵构造函数

GLSL ES 中的矩阵是[[003.绘制和变换三角形#^lzs|按列主序]]的，所以要注意传入值的顺序：

```glsl
mat4 m4 = mat4(
1.0, 2.0, 3.0,
4.0, 5.0, 6.0,
7.0, 8.0, 9.0
);
// 1.0 4.0 7.0
// 2.0 5.0 8.0
// 3.0 6.0 9.0
```

向矩阵构造函数中传入矢量和数值，按照列主序使用矢量里的元素值来构造矩阵：

```glsl
// 使用两个 vec2 来创建 mat2
vec2 v2a = vec2(1.0, 3.0);
vec2 v2b = vec2(2.0, 4.0);
mat2 m2a = mat2(v2a, v2b);
// 1.0 2.0
// 3.0 4.0

// 使用一个 vec4 来创建 mat2
vec4 v4 = vec4(1.0, 3.0, 2.0, 4.0);
mat2 m2b = mat2(v4);
// 1.0 2.0
// 3.0 4.0

// 使用两个浮点数和一个 vec2 来创建 mat2
mat2 m2c = mat2(1.0, 3.0, v2b);
// 1.0 2.0
// 3.0 4.0

// 只传一个数值，就是单位矩阵
mat4 m4a = mat4(1.0);
// 1.0 0.0 0.0 0.0
// 0.0 1.0 0.0 0.0
// 0.0 0.0 1.0 0.0
// 0.0 0.0 0.0 1.0

// 同样如果传入的数值的数量大于一，又没有达到矩阵元素的数量，就会报错
mat4 m4b = mat4(1.0, 2.0, 3.0); // 报错
```

## 访问元素

### `.` 运算符

分量名：

- `x`、`y`、`z`、`w`：用来获取顶点坐标分量
- `r`、`g`、`b`、`a`：用来获取颜色分量
- `s`、`t`、`p`、`q`：用来获取纹理坐标分量

不同类别的分量名可以增强程序的可读性。事实上，任何矢量的 `x`、`r`、`s` 分量都会返回第 1 个分量，`y`、`g`、`t` 分量都返回第 2 个分量，等等。如果愿意，可以随意地交换使用它们（尽量不要这样做，可读性很差）：

```glsl
vec3 v3 = vec3(1.0, 2.0, 3.0);
float f;

f = v3.x; // 1.0
f = v3.g; // 2.0
f = v3.q; // 报错，vec3 没有第 4 个分量
v3.z = 3.3; // 也可以作为 = 左值
```

将同一个集合的多个分量名共同置于点运算符后，就可以从矢量中同时抽取出多个分量，这个过程称作混合（swizzling）：

```glsl
vec2 v2;
v2 = v3.xy; // (1.0, 2.0)
v2 = v3.yx; // (2.0, 1.0)
v2 = v3.xx; // (1.0, 1.0)

// 其他类别分量名也可以
v2 = v3.rg; // (1.0, 2.0)

// 但不能跨类别了
v2 = v3.ry; // 报错

// 同样可以作为 = 左值
v3.yx = vec2(2.2, 1.1);
```

### `[]` 运算符

```glsl
vec3 v3 = vec3(1.0, 2.0, 3.0);
float f = v3[2]; // 3.0

mat3 m3 = mat3(
1.0, 2.0, 3.0,
4.0, 5.0, 6.0,
7.0, 8.0, 9.0
);
vec3 v3b = m3[0]; // (1.0, 2.0, 3.0)，获取 m4 矩阵的第 1 列
float m11 = m3[1][1]; // 5.0
float m12 = m3[1].z; // 6.0
```

 注意，`[]` 中只能出现的索引值必须是常量索引值（constant index）：

- 整型字面量
- 用 `const` 修饰的全局变量或局部变量，不包括函数参数
- 循环索引（详见）
- 由前述三条中的项组成的表达式

```glsl
const int idx = 0;
vec3 v3c = m3[idx]; // 同 m3[0]
vec3 v3d = m3[idx + 1]; // 同 m3[1]

int idx2 = 0;
vec3 v3e = m3[idx2]; // 报错：idx2 不是常量索引
```

## 运算符

![[Pasted image 20240819224623.png]]

 矢量和矩阵不可以使用 `>`、`<`、`>=`、`<=`，如果你想比较矢量和矩阵的大小，应该使用内置函数，如 `lessThan()`（详见）
