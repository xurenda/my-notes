---
date: 2024-03-22 19:47
modified: 2024-03-26 17:46
---

# 概述

回顾登录的流程：

![[image-20200417161950450.png]]

接下来的问题是：这个出入证（令牌）里面到底存啥？

一种比较简单的办法就是直接存储用户信息的 JSON 串，这会造成下面的几个问题：

- 非浏览器环境，如何在令牌中记录过期时间
- 如何防止令牌被伪造

JWT 就是为了解决这些问题出现的。JWT 全称 Json Web Token，本质就是一个字符串。它要解决的问题，就是在互联网环境中，提供统一的、安全的令牌格式。

因此，JWT 只是一个令牌格式而已，可以把它存储到 cookie，也可以存储到 localStorage，或者非浏览器环境的本地存储中，没有任何限制。

同样的，对于传输，可以使用任何传输方式来传输 JWT，一般来说，会使用消息头或消息体来传输它

比如，当登录成功后，服务器可以给客户端响应一个 JWT：

```http
HTTP/1.1 200 OK
Set-Cookie: token=JWT 令牌
Authentication: JWT 令牌
...

{ ..., "token": JWT 令牌 }
```

可以看到，JWT 令牌可以出现在响应的任何一个地方，客户端和服务器自行约定即可。

当然，也可以出现在响应的多个地方，比如为了充分利用浏览器的 cookie，同时照顾其他设备，可以让 JWT 出现在 `set-cookie` 和消息头或消息体中。

当客户端拿到令牌后，它要做的只有一件事：存储它。可以存储到任何位置，比如手机文件、PC 文件、localStorage、cookie 等本地存储中。

当后续请求发生时，只需要将它作为请求的一部分发送到服务器即可。虽然 JWT 没有明确要求应该如何附带到请求中，但通常会使用如下的格式：

```http
GET /api/resources HTTP/1.1
Authorization: bearer JWT 令牌
...
```

这样一来，服务器就能够收到这个令牌了，通过对令牌验证，即可知道该令牌是否有效。

它们的完整交互流程是非常简单清晰的：

![[image-20200422172837190.png]]

# 令牌的组成

为了保证令牌的安全性，JWT 由三个部分组成，分别是：

1. `header`：令牌头部，记录了整个令牌的类型和签名算法
2. `payload`：令牌载荷，记录了保存的主体信息，开发者可以加一些自定义的内容
3. `signature`：令牌签名，按照 `header` 固定的签名算法对整个令牌进行签名，该签名的作用是：保证令牌不被伪造和篡改

它们组合而成的完整格式是：`header.payload.signature`

## `header`

它是令牌头部，记录了整个令牌的类型和签名算法，格式是一个 JSON 对象的 [[#Base64 URL|Base64 URL]] 编码，如下：

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

该对象记录了：

- `alg`：`signature` 部分使用的签名算法，通常可以取两个值
    - HS256：一种对称加密算法，使用同一个秘钥进行加解密
    - RS256：一种非对称加密算法，使用私钥签名，公钥验证
- `typ`：整个令牌的类型，一般固定写 `JWT`

## `payload`

这部分是 JWT 的主体信息，它仍然是一个 JSON 对象，可以包含以下内容：

```json
{
  "ss"："发行者",
  "iat"："发布时间",
  "exp"："到期时间",
  "sub"："主题",
  "aud"："听众",
  "nbf"："在此之前不可用",
  "jti"："JWT ID"
}
```

以上属性可以全写，也可以一个都不写，它只是一个规范，就算写了，也需要你在将来验证这个 JWT 令牌时手动处理才能发挥作用

上述属性表达的含义分别是：

- `ss`：发行该 JWT 的是谁，可以写公司名字，也可以写服务名称
- `iat`：该 JWT 的发放时间，通常写当前时间的时间戳
- `exp`：该 JWT 的到期时间，通常写时间戳
- `sub`：该 JWT 是用于干嘛的
- `aud`：该 JWT 是发放给哪个终端的，可以是终端类型，也可以是用户名称，随意一点
- `nbf`：一个时间点，在该时间点到达之前，这个令牌是不可用的
- `jti`：JWT 的唯一编号，设置此项的目的主要是为了防止重放攻击（重放攻击是在某些场景下，用户使用之前的令牌发送到服务器，被服务器正确的识别，从而导致不可预期的行为发生）

当然开发者可以加一些自定义的内容

## `signature`

这一部分是 JWT 的签名，正是它的存在，保证了整个 JWT 不被篡改

这部分的生成，是对前面两个部分的编码结果，按照 `header` 指定的方式进行加密

比如：头部指定的加密方法是 `HS256`，前面两部分的编码结果是 `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9`

则第三部分就是用对称加密算法 `HS256` 对字符串 `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9` 进行加密，当然得指定一个秘钥，比如 `shhhhh`：

```js
HS256(`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1ODc1NDgyMTV9`, "shhhhh")
// 得到：BCwUy3jnUQ_E6TqCayc7rCHkx-vxxdagUwPOWqwYCFc
```

最终，将三部分组合在一起，就得到了完整的 JWT。

由于签名使用的秘钥保存在服务器，这样一来，客户端就无法伪造出签名，因为它拿不到秘钥。换句话说，之所以说无法==伪造== JWT，就是因为第三部分的存在。

而前面两部分并没有加密，只是一个编码结果而已，可以认为几乎是明文传输。所以要保证不要把敏感的信息存放到 JWT 中，比如密码。

# 令牌验证

令牌在服务器组装完成后，会以任意的方式发送到客户端，客户端会把令牌保存起来，后续的请求会将令牌发送给服务器，而服务器需要验证令牌是否正确，如何验证呢？

首先，服务器要验证这个令牌是否被==篡改==过，验证方式非常简单，就是对 `header.payload` 用同样的秘钥和加密算法进行重新加密

然后把加密的结果和传入 JWT 的 `signature` 进行对比，如果完全相同，则表示前面两部分没有动过，就是自己颁发的，如果不同，肯定是被篡改过了。

当令牌验证为没有被篡改后，服务器可以进行其他验证：比如是否过期、听众是否满足要求等等，这些就视情况而定了。

# 总结

最后，总结一下 JWT 的特点：

- JWT 本质上是一种令牌格式。它和终端设备无关，同样和服务器无关，甚至与如何传输无关，它只是规范了令牌的格式而已
- JWT 由三部分组成：`header`、`payload`、`signature`。主体信息在 `payload`
- JWT 难以被篡改和伪造，这是因为有第三部分的签名存在。

# Base64

## 标准的 Base64

Base64 不是一种加密算法，而是一种编码方式。

就是基于 64 个可打印字符来表示二进制数据的方法：

- 小写字母 a-z
- 大写字母 A-Z
- 数字 0-9
- 符号 `+`、`/`

## 编码规则

1. 把 3 个字节变成 4 个字节
2. 每 76 个字符加一个换行符
3. 最后的结束符也要处理

如：

- 原字符串 `s13`
- 转成 ascii 对应：115, 49, 51
- 二进制： 01110011, 00110001, 00110011
- 6个一组（4 组）： 011100, 110011, 000100, 110011
- 计算机一个字节占 8 位，不够高位补 0：00011100, 00110011, 00000100, 00110011
- 得到：28, 51, 4, 51
- 对照表：`czEz`

原文的字节数量应该是 3 的倍数，如果这个条件不能满足的话，具体的解决办法是这样的：原文剩余的字节根据编码规则继续单独转（1 变 2，2 变 3；不够的位数用 0 补全），再用 `=` 补满 4 个字节。

这就是为什么有些 Base64 编码会以一个或两个等号结束的原因，但等号最多只有两个。因为一个原字节至少会变成两个目标字节，所以余数任何情况下都只可能是 0，1，2 这三个数中的一个：

- 如果余数是 0 的话，就表示原文字节数正好是 3 的倍数（最理想的情况）
- 如果是 1 的话，转成 2 个 Base64 编码字符，为了让 Base64 编码是 4 的倍数，就要补 2 个等号
- 同理，如果是 2 的话，就要补 1 个等号

## 应用

很多下载类网站都提供“迅雷下载”的链接，其地址通常是加密的迅雷专用下载地址。其实迅雷的“专用地址”也是用 Base64 “加密”的，其过程如下：

1. 在地址的前后分别添加 `AA` 和 `ZZ`
2. 对新的字符串进行 Base64 编码

另外 Flashget 的与迅雷类似，只不过在第一步时加的“料”不同罢了，Flashget 在地址前后加的“料”是 `[FLASHGET]`

而 QQ 旋风的干脆不加料，直接就对地址进行 Base64 编码了

## Base64 URL

标准的 Base64 并不适合直接放在 URL 里传输，因为 URL 编码器会把标准 Base64 中的 `+` 和 `/` 字符变为形如 `%XX` 的形式，而这些 `%` 在存入数据库时还需要再进行转换，因为 ANSI SQL 中已将 `%` 号用作通配符。

为解决此问题，可采用一种用于 URL 的改进 Base64 编码，它在末尾填充 `=`，并将标准 Base64 中的 `+` 和 `/` 分别改成了 `-` 和 `_`，这样就免去了在 URL 编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。

浏览器提供了 `btoa` 函数，可以将字符串转换成 Base64 URL 字符串；反之也提供了 `atob` 函数

node 没有提供这两个函数，可以安装第三方库 `atob` 和 `bota`，或者自己写

## Base64 其他变种

另有一种用于正则表达式的改进 Base64 变种，它将 `+` 和 `/` 改成了 `!` 和 `-`，因为 `+`、`/` 在正则表达式中都具有特殊含义。

此外还有一些变种，它们将 `+`、`/` 改为 `_-` 或 `._`（用作编程语言中的标识符名称）或 `.-`（用于 XML 中的 Nmtoken）甚至 `_:`（用于 XML 中的 Name）。
