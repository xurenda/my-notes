---
date: 2024-08-11 02:31
modified: 2024-08-11 13:39
---

# 异步处理

## 阶段一：回调函数

当异步任务完成，调用对应回调函数（一般有两个：成功回调和失败回调），并将数据或错误以函数参数传入

## 阶段二：`Promise`

ES6 新增的 API，目的是为了解决异步处理中回调函数方式的一些问题：

1. 回调地狱：回调函数层层嵌套（回调套回调），代码难以阅读和维护
2. 控制反转：如不能保证回调函数被正确调用（一个回调可能被调用多次、成功回调和失败回调都被调用）
	- 规则 VS. 规范

`Promise` 如何解决？

1. `.then(...).then(...)` 打平，无需嵌套
2. `Promise` 的状态只能够改变一次（`pending → resolved` 或 `pending → rejected`）

`Promise` 可以完全代替回调函数？

- 不能。需要多次调用的回调函数、事件的回调函数（写成 `Promise` 很奇怪）

## 阶段三：`Generator` 函数

生成器函数可以退出，并在稍后重新进入，其上下文（变量[绑定](https://developer.mozilla.org/zh-CN/docs/Glossary/Binding)）会在重新进入时保存

`function*` 声明创建一个 [`GeneratorFunction`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction) 对象。每次调用生成器函数时，它都会返回一个新的 [`Generator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator) 对象，该对象符合[迭代器协议](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE)。当迭代器的 `next()` 方法被调用时，生成器函数的主体会被执行，直到遇到第一个 [`yield`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield) 表达式，该表达式指定了迭代器要返回的值，或者用 [`yield*`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield*) 委托给另一个生成器函数。`next()` 方法返回一个对象，其 `value` 属性包含了 `yield` 表达式的值，`done` 属性是布尔类型，表示生成器是否已经返回了最后一个值。如果 `next()` 方法带有参数，那么它会恢复生成器函数的执行，并用参数替换暂停执行的 `yield` 表达式

其本质就是一个状态机

## 阶段四：`async`、`await`

`Promise` + `GeneratorFunction` 的语法糖，可以写看起来像同步的代码而完成异步编程

# 知识点

- `new Promise()` 参数中的函数是同步代码，`.then` 中的回调放入微任务队列，放入时机：
	- 调用 `.then` 时 `Promise` 还是 `pending`：当 `Promise` 完成时（`resolve` 或 `reject`）放入
	- 调用 `.then` 时 `Promise` 状态已改变：立即放入
- 每调用一个 `.then` 就产生一个新的 `Promise` 并作为返回值（`.then` 的链式调用），其状态取决于该 `then` 中回调函数的返回值：
	- 返回普通值：状态是成功（`resolved`），相当于：`Promise.resolve(返回值)`
	- 返回 `Promise`：与返回的 `Promise` 状态保持一致，如何保持一致取决于 JS 引擎具体实现，如 V8：
		- 记：`then` 回调返回的 `Promise` 为 `p_return`；该 `then` 产生的 `Promise` 为 `p_then`
		- `p_return` 完成后会将 `p_return.then(() => p_then 完成)` 推入微队列
		- [https://www.bilibili.com/video/BV1Nh4y127EM](https://www.bilibili.com/video/BV1Nh4y127EM)
- `await xxx` 相当于：xxx 同步执行，如果不是一个 `Promise` 则使用 `Promise.resolve()` 包裹，当该 `Promise` 完成后把后面所有的执行语句放入 `then` 回调中（如果没有后续语句则推入“函数完成”到微任务队列 ）
- `async` 函数返回一个 `Promise`，如果不是 `Promise` 则使用 `Promise.resolve()` 包裹
- `async` 函数具有传染性，消除传染性：
	- 调两次，第一次抛出 `Promise`，在该 `Promise` 中进行异步操作，在外部捕获该错误，`Promise` 完成后再次调用函数
	- React 的 `<Suspense fallback={Loading}>child</Suspense>` 就是如此实现的
	- [https://www.bilibili.com/video/BV1hp4y1A71j/](https://www.bilibili.com/video/BV1hp4y1A71j/)

# 题目

## 1

```js
async function async1() {
	console.log(1);
	await async2();
	console.log(2);
}

async function async2() {
	console.log(3);
}

console.log(4);

setTimeout(function () {
	console.log(5);
}, 0)

async1();

new Promise(function (resolve) {
	console.log(6);
	resolve();
}).then(function () {
	console.log(7);
});

console.log(8);
```

> [!NOTE]- 答案
> 
> `4 1 3 6 8 2 7 5`

## 2

```js
console.log(1);

setTimeout(() => {
	console.log(2);
	Promise.resolve().then(() => {
		console.log(3);
	})
}, 0);

new Promise(function (resolve, reject) {
	console.log(4);
	setTimeout(function () {
		console.log(5);
		resolve(6);
	}, 0);
}).then((res) => {
	console.log(7);
	setTimeout(() => {
		console.log(res);
	}, 0);
})
```


> [!NOTE]- 答案
> 
> `1 4 2 3 5 7 6`

## 3

```js
const p = function() {
	return new Promise((resolve, reject) => {
		const p1 = new Promise((resolve, reject) => {
			setTimeout(() => {
				resolve(1);
			}, 0);
			resolve(2);
		});
	
		p1.then((res) => {
			console.log(res);
		})
	
		console.log(3);
		resolve(4);
	});
}

p().then((res) => {
	console.log(res);
});
console.log ('end');
```

> [!NOTE]- 答案
> 
> `3 end 2 4`

## 4

```js
const p = function() {
	return new Promise((resolve, reject) => {
		const p1 = new Promise((resolve, reject) => {
			setTimeout(() => {
				resolve(1);
			}, 0);
//			resolve(2);
		});
	
		p1.then((res) => {
			console.log(res);
		})
	
		console.log(3);
		resolve(4);
	});
}

p().then((res) => {
	console.log(res);
});
console. log ('end');
```

> [!NOTE]- 答案
> 
> `3 end 4 1`

## 5

```js
async function f1() {
  console.log(1)
  await f2()
  console.log(2)
}

f2 = async () => {
  await setTimeout(() => {
    Promise.resolve().then(() => {
	  console.log(3)
    })
    console.log(4)
  })
}

f3 = async () => {
  Promise.resolve().then(() => {
    console.log(6)
  })
}

f1()
console.log(7)
f3()
```

> [!NOTE]- 答案
> 
> `1 7 6 2 4 3`
> 
> [https://www.bilibili.com/video/BV1ab421J76k/](https://www.bilibili.com/video/BV1ab421J76k/)

## 6

```js
async function f1() {
  console.log(1)
  await f2()
  console.log(2)
}

f2 = async () => {
  await (async () => {
    await (() => {
      console.log(3)
    })()
    console.log(4)
  })()
}

f3 = async () => {
  Promise.resolve().then(() => {
    console.log(6)
  })
}

f1()
console.log(7)
f3()
```

> [!NOTE]- 答案
> 
> `1 3 7 4 6 2`

## 7

```js
Promise.resolve().then(() => {
  console.log(0)
  return Promise.resolve(4)
}).then(res => {
  console.log(res)
})

Promise.resolve().then(() => {
  console.log(1)
}).then(res => {
  console.log(2)
}).then(res => {
  console.log(3)
}).then(res => {
  console.log(5)
}).then(res => {
  console.log(6)
})
```

> [!NOTE]- 答案
> 
> `0 1 2 3 4 5 6`
> 
> [ https://www.bilibili.com/video/BV1Nh4y127EM ]( https://www.bilibili.com/video/BV1Nh4y127EM )
