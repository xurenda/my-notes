---
date: 2023-12-29 13:46
modified: 2024-01-12 11:28
---

>前置知识：会使用 [[013.队列和栈-链表、数组实现#队列|队列]]、[[016.双端队列-双链表和固定数组实现|双端队列]]、[[007.堆结构和堆排序#堆结构|优先级队列（堆）]]、[[018.二叉树高频题目-上-不含树型dp|二叉树上的宽度优先遍历]]、[[020.常见经典递归过程解析|经典递归过程解析]]、[[041.建图、链式前向星、拓扑排序|图]]

本节课讲述：

- 单源、多源宽度优先遍历基本过程
- 01bfs，宽度优先遍历与双端队列结合
- 宽度优先遍历与优先级队列结合
- 宽度优先遍历与深度优先遍历结合，去生成路径

# 宽度优先遍历基本内容

1. bfs 的特点是逐层扩散，从源头点到目标点扩散了几层，最短路就是多少
2. bfs 可以使用的特征是==任意两个节点之间的相互距离相同==（无向图）
	- 从 `A` 扩到 `B` 和 从 `B` 扩到 `A` 都是层数 +1
	- 如果是有向图：`A -> B` 权重 1，`B -> A` 权重 2，则一般宽度优先遍历是不行的
	- 要使用 Dijkstra 算法来解
3. bfs 开始时，可以是==单个源头==、也可以是==多个源头==
4. bfs 频繁使用队列，形式可以是==单点弹出==或者==整层弹出==
5. bfs 进行时，进入队列的节点需要标记状态，防止同一个节点重复进出队列
	- `visited`：标识一个节点是否已经处理过了，处理过的节点再遇到就直接跳过
6. bfs 进行时，可能会包含 [[020.常见经典递归过程解析#剪枝|剪枝]] 策略的设计
7. bfs 是一个理解难度很低的算法，难点在于==节点如何找到路==、==路的展开==和==剪枝设计==

## 题目1.地图分析

### 题目描述

你现在手里有一份大小为 `n x n` 的 网格 `grid`，上面的每个 单元格 都用 `0` 和 `1` 标记好了。其中 `0` 代表海洋，`1` 代表陆地。

请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回 `-1`。

我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：`(x0, y0)` 和 `(x1, y1)` 这两个单元格之间的距离是 `|x0 - x1| + |y0 - y1|` 。

提示：

- `n == grid.length`
- `n == grid[i].length`
- `1 <= n <= 100`
- `grid[i][j]` 不是 `0` 就是 `1`

### 测试链接

[1162.地图分析](https://leetcode.cn/problems/as-far-from-land-as-possible/)

### 思路

题目相当于求：从陆地出发（所有陆地同时出发），能达到的最远海洋

小技巧：优雅完成向上下左右移动

```go
move := []int{-1, 0, 1, 0, -1}

for i := 0; i < 4; i++ {
	// (x, y): (x + move[i], y + move[i+1])
	// i 来到 0 位置: (x-1, y)，向上
	// i 来到 1 位置: (x, y+1)，向右
	// i 来到 2 位置: (x+1, y)，向下
	// i 来到 3 位置: (x, y-1)，向左
}
```

### 答案

```go
const (
	MAXN = 101
)

var (
	n          int
	queue      = [MAXN * MAXN][2]int{}
	head, tail = 0, 0
	visited    = [MAXN][MAXN]bool{}
	move       = [5]int{-1, 0, 1, 0, -1}
)

func maxDistance(grid [][]int) int {
	head, tail = 0, 0
	n = len(grid)
	seas := 0
	for i := 0; i < n; i++ {
		for j := 0; j < n; j++ {
			if grid[i][j] == 1 {
				visited[i][j] = true
				// 多个源头
				queue[tail][0] = i
				queue[tail][1] = j
				tail++
			} else {
				visited[i][j] = false
				seas++
			}
		}
	}

	if seas == 0 || seas == n*n {
		return -1
	}

	level := 0
	size := 0
	x, y := 0, 0
	nextX, nextY := 0, 0
	for head < tail {
		level++
		size = tail - head
		// 整层弹出
		for i := 0; i < size; i++ {
			x = queue[head+i][0]
			y = queue[head+i][1]
			for j := 0; j < 4; j++ {
				nextX = x + move[j]
				nextY = y + move[j+1]
				if nextX >= 0 && nextX < n && nextY >= 0 && nextY < n && !visited[nextX][nextY] {
					visited[nextX][nextY] = true
					queue[tail][0] = nextX
					queue[tail][1] = nextY
					tail++
				}
			}
		}
		head += size
	}

	return level - 1
}
```

### 复杂度

- 时间复杂度：$O(n*m)$，矩阵的大小
	- 遍历矩阵每个位置上下左右扩，不管怎么扩，每个位置只处理一次（进出队列一次）
- 空间复杂度：$O(n*m)$，队列

## 题目2.贴纸拼词

### 题目描述

我们有 `n` 种不同的贴纸。每个贴纸上都有一个小写的英文单词。

您想要拼写出给定的字符串 `target` ，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。

返回你需要拼出 `target` 的最小贴纸数量。如果任务不可能，则返回 `-1` 。

注意：在所有的测试用例中，所有的单词都是从 `1000` 个最常见的美国英语单词中随机选择的，并且 `target` 被选择为两个随机单词的连接。

提示:

- `n == stickers.length`
- `1 <= n <= 50`
- `1 <= stickers[i].length <= 10`
- `1 <= target.length <= 15`
- `stickers[i]` 和 `target` 由小写英文单词组成

### 测试链接

[691.贴纸拼词](https://leetcode.cn/problems/stickers-to-spell-word/)

### 思路

还可以用动态规划来解

### 答案

### 复杂度

# 01bfs

适用于==图中所有边的权重只有 0 和 1 两种值==，求源点到目标点的最短距离

时间复杂度为 $O(节点数量+边的数量)$

## 为什么不能用传统 bfs？

![[01bfs 为什么不能用传统 bfs.excalidraw]]

传统 bfs 下面的那条路会先走到 B，B 节点标记为已访问过的节点，上面那条路就不会走到了。或者修改逻辑可以走到，也会导致后来的值修改之前的值，逻辑很难写

除非将边先按权重进行排序后再使用传统 bfs，但这样的话时间复杂度太高了

## 思路

1. `distance[i]` 表示从源点到 `i` 点的最短距离，初始时所有点的 `distance` 设置为无穷大
2. 源点进入双端队列，`distance[源点] = 0`（自己到自己的距离为 0）
3. 双端队列，头部弹出 `x`
	- 如果 `x` 是目标点，返回 `distance[x]` 表示源点到目标点的最短距离
	- 否则考察从 `x` 出发的每一条边，假设某边去 `y` 点，边权为 `w`
		- 如果 `distance[y] > distance[x] + w`，处理该边；否则忽略该边
		- 处理时，更新 `distance[y] = distance[x] + w`。如果 `w==0`，`y` 从头部进入双端队列；如果 `w==1`，`y` 从尾部进入双端队列
		- 考察完 `x` 出发的所有边之后，重复步骤 3
4. 双端队列为空停止

## 正确性证明

正确性证明以及为什么不需要 `visited` 来标记节点

双端队列中任意两个节点，原点和它们的距离差不会超过 1

从头部出队列的元素 `distance[x]` 就是它到原点的距离

- `w==1`：从尾部进入双端队列
- `w==0`：从头部进入双端队列

权重为 0，从头部进就修正了它的距离，使其变得更小。即使双端队列后面还有一个相同的元素弹出时，它的 `distance[x]` 已经被之前弹出的相同元素修正对了。一个节点最多进双端队列两次，这也正是不需要 `visited` 来标记节点的原因

![[01bfs.excalidraw]]

## 宽度优先遍历与优先级队列结合

宽度优先遍历与优先级队列结合，更进一步的内容会在讲 Dijkstra 算法时说明

宽度优先遍历与深度优先遍历结合，去生成路径

1，bfs建图

2，dfs利用图生成路径
