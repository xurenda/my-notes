---
date: 2023-12-29 13:46
modified: 2023-12-29 13:51
---

>前置知识：会使用 [[013.队列和栈-链表、数组实现#队列|队列]]、[[016.双端队列-双链表和固定数组实现|双端队列]]、[[007.堆结构和堆排序#堆结构|优先级队列（堆）]]、[[018.二叉树高频题目-上-不含树型dp|二叉树上的宽度优先遍历]]、[[020.常见经典递归过程解析|经典递归过程解析]]、[[041.建图、链式前向星、拓扑排序|图]]

本节课讲述：

- 单源、多源宽度优先遍历基本过程
- 01bfs，宽度优先遍历与双端队列结合
- 宽度优先遍历与优先级队列结合
- 宽度优先遍历与深度优先遍历结合，去生成路径

# 宽度优先遍历基本内容

1. bfs 的特点是逐层扩散，从源头点到目标点扩散了几层，最短路就是多少
2. bfs 可以使用的特征是==任意两个节点之间的相互距离相同==（无向图）
	- 从 `A` 扩到 `B` 和 从 `B` 扩到 `A` 都是层数 +1
	- 如果是有向图：`A -> B` 权重 1，`B -> A` 权重 2，则一般宽度优先遍历是不行的
	- 要使用 Dijkstra 算法来解
3. bfs 开始时，可以是==单个源头==、也可以是==多个源头==
4. bfs 频繁使用队列，形式可以是==单点弹出==或者==整层弹出==
5. bfs 进行时，进入队列的节点需要标记状态，防止同一个节点重复进出队列
	- `visited`：标识一个节点是否已经处理过了，处理过的节点再遇到就直接跳过
6. bfs 进行时，可能会包含 [[020.常见经典递归过程解析#剪枝|剪枝]] 策略的设计
7. bfs 是一个理解难度很低的算法，难点在于==节点如何找到路==、==路的展开==和==剪枝设计==

## 题目1.地图分析

### 题目描述

你现在手里有一份大小为 `n x n` 的 网格 `grid`，上面的每个 单元格 都用 `0` 和 `1` 标记好了。其中 `0` 代表海洋，`1` 代表陆地。

请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回 `-1`。

我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：`(x0, y0)` 和 `(x1, y1)` 这两个单元格之间的距离是 `|x0 - x1| + |y0 - y1|` 。

提示：

- `n == grid.length`
- `n == grid[i].length`
- `1 <= n <= 100`
- `grid[i][j]` 不是 `0` 就是 `1`

### 测试链接

[1162.地图分析](https://leetcode.cn/problems/as-far-from-land-as-possible/)

### 思路

小技巧：优雅完成向上下左右移动

```go
move := []int{-1, 0, 1, 0, -1}

for i := 0; i < 4; i++ {
	// (x, y): (x + move[i], y + move[i+1])
	// i 来到 0 位置: (x-1, y)，向上
	// i 来到 1 位置: (x, y+1)，向右
	// i 来到 2 位置: (x+1, y)，向下
	// i 来到 3 位置: (x, y-1)，向左
}
```

### 答案

### 复杂度

- 时间复杂度：$O(n*m)$，矩阵的大小
	- 遍历矩阵每个位置上下左右扩，不管怎么扩，每个位置只处理一次（进出队列一次）
- 空间复杂度：$O(n*m)$，队列

## 题目2.贴纸拼词

### 题目描述

### 测试链接

### 思路

还可以用动态规划来解

### 答案

### 复杂度

