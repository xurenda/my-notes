---
date: 2023-12-19 15:37
modified: 2023-12-19 16:04
---

>前置知识：[[003.二进制和位运算|二进制和位运算]]、[[005.对数器-验证的重要手段|对数器]]
>
>特别提醒：Python 的同学实现位运算的题目需要特别注意，需要自己去手动处理溢出和符号扩展等问题，比如：`(n << shift_amount) & 0xFFFFFFFF`（Python 溢出会自动升位：$32 \rightarrow 64$）

# 位图原理

其实就是用 bit 组成的数组来存放值，用 bit 状态 1、0 代表存在、不存在，取值和存值操作都用位运算

- 限制是必须为连续范围且不能过大（一开始就会申请这么大的空间）
- 好处是极大的节省空间，因为 1 个数字只占用 1 个 bit 的空间

# 位图的实现

```go
package main

import (
  "fmt"
  "math/rand"
  "unsafe"
)

const (
  INT_BIT_COUNT = int(unsafe.Sizeof(int(0))) * 8 // int 占的位数
  MAXN          = 10000
  TEST_TIMES    = 100000
)

var emptyStruct = struct{}{}

func main() {
  bitSet := NewBitset(MAXN)
  hashSet := make(map[int]struct{}, MAXN)

  for i := 0; i < TEST_TIMES; i++ {
    num := rand.Intn(MAXN)
    decide := rand.Intn(3)
    switch decide {
    case 0:
      bitSet.Add(num)
      hashSet[num] = emptyStruct
    case 1:
      bitSet.Remove(num)
      delete(hashSet, num)
    case 2:
      bitSet.Reverse(num)
      if _, has := hashSet[num]; has {
        delete(hashSet, num)
      } else {
        hashSet[num] = emptyStruct
      }
    }
  }

  for i := 0; i < MAXN; i++ {
    if _, has := hashSet[i]; has != bitSet.Contains(i) {
      panic("error")
    }
  }
  fmt.Println("success")
}

// 位图
// 使用时 num 不要超过初始化的大小
type Bitset []int

// n个数字: [0, n)
func NewBitset(n int) Bitset {
  // a / b 想向上取整，可以写成: (a+b-1) / b
  // 前提是 a 和 b 都是非负数
  return make(Bitset, (n+INT_BIT_COUNT-1)/INT_BIT_COUNT)
}

// 把 num 加入位图
func (b Bitset) Add(num int) {
  b[num/INT_BIT_COUNT] |= 1 << (num % INT_BIT_COUNT)
}

// 把 num 从位图中删除
func (b Bitset) Remove(num int) {
  b[num/INT_BIT_COUNT] &^= 1 << (num % INT_BIT_COUNT)
}

// 如果位图里没有 num，就加入
// 如果位图里有 num，就删除
func (b Bitset) Reverse(num int) {
  b[num/INT_BIT_COUNT] ^= 1 << (num % INT_BIT_COUNT)
}

// 查询 num 是否在位图中
func (b Bitset) Contains(num int) bool {
  return b[num/INT_BIT_COUNT]&(1<<(num%INT_BIT_COUNT)) != 0
}
```

采用对数器验证，当你找不到测试链接的时候就用对数器验证，而且对数器验证更稳妥、更能练习 debug 能力

找到了一个相关测试：[2166.设计位集](https://leetcode.cn/problems/design-bitset/)

# 备注

位图的后续扩展，将在【扩展】课程里进一步讲述
