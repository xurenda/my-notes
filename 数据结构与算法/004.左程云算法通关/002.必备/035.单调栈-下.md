---
date: 2023-12-29 13:46
modified: 2023-12-29 13:51
---

>前置知识：[[034.单调栈-上|单调栈-上]]

除了单调栈最经典的用法之外，在很多问题里单调栈还可以==维持求解答案的可能性==

1. 单调栈里的所有对象按照==规定好的单调性==来组织
2. 当某个对象进入单调栈时，会从==栈顶开始==依次淘汰单调栈里==对后续求解答案没有帮助==的对象
3. 每个对象从栈顶弹出的时==结算当前对象参与的答案==，随后这个对象==不再参与后续求解答案==的过程
4. 其实是先有对题目的分析！进而发现单调性，然后利用单调栈的特征去实现

## 备注

单调栈可以和很多技巧交叉使用！比如：动态规划 + 单调栈优化，会在【扩展】课程里讲述

# 题目1.最大宽度坡

## 题目描述

给定一个整数数组 `A`，坡是元组 `(i, j)`，其中  `i < j` 且 `A[i] <= A[j]`。这样的坡的宽度为 `j - i`。

找出 `A` 中的坡的最大宽度，如果不存在，返回 0 。

提示：

- `2 <= A.length <= 50000`
- `0 <= A[i] <= 50000`

## 测试链接

[962.最大宽度坡](https://leetcode.cn/problems/maximum-width-ramp/)

## 答案

```go
func maxWidthRamp(nums []int) int {
	stack := []int{0}
	n := len(nums)
	// 栈底 -> 栈顶：大 -> 小
	// 收集到的都是可能为答案的左位置
	// [小 大   右位置]
	// 如果能以“大”为左位置，“右位置”为右位置得到答案
	// 则说明“右位置”比“大”要大
	// 那以“小”为左位置，“右位置”为右位置得到答案会更宽
	// 所以答案不可能以“大”为左位置
	for i := 1; i < n; i++ {
		if nums[stack[len(stack)-1]] > nums[i] {
			stack = append(stack, i)
		}
	}

	ans := 0
	for i := n - 1; i >= 0; i-- {
		// 以 i 为右位置，栈中元素都是可能作为左位置的
		// 左位置 <= 右位置：结算答案
		// 并弹出栈：因为这个左位置已经和最右的右位置结算过了
		// 之后它（左位置）不可能得到更好的答案了
		for len(stack) > 0 && nums[stack[len(stack)-1]] <= nums[i] {
			ans = max(ans, i-stack[len(stack)-1])
			stack = stack[:len(stack)-1]
		}
	}
	return ans
}
```

## 复杂度

- 时间复杂度：$O(n)$，所有元素只进栈出栈一次
- 空间复杂度：$O(n)$，单调栈的空间

# 题目2.标题

## 题目描述

给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。

示例 1：

>输入：`s = "bcabc"`
>
>输出：`"abc"`

示例 2：

>输入：`s = "cbacdcbc"`
>
>输出：`"acdb"`

提示：

- `1 <= s.length <= 10^4`
- `s` 由小写英文字母组成

## 测试链接

- [316.去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/)
- [1081.不同字符的最小子序列](https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/)

## 思路

## 答案

## 复杂度
