---
date: 2023-12-29 13:46
modified: 2024-02-01 20:05
---

>前置知识：[[020.常见经典递归过程解析|经典递归过程解析]]、[[048.从递归入手一维动态规划|从递归入手一维动态规划]]

本节课：

- 讲解从递归到二维动态规划的过程
- 讲解二维动态规划的空间压缩技巧
- 讲解哪些递归不适合或者说没有必要改成动态规划

下节课：直接从动态规划的定义入手，来见识更多二维动态规划问题

# 二维动态规划

尝试函数有一个可变参数可以完全决定返回值，进而可以改出一维动态规划表的实现

同理，尝试函数有两个可变参数可以完全决定返回值，那么就可以改出两维动态规划的实现

一维、二维、三维甚至多维动态规划问题，大体过程都是：

1. 写出尝试递归
2. 记忆化搜索（从顶到底的动态规划，复杂 -> 简单）
3. 严格位置依赖的动态规划（从底到顶的动态规划，简单 -> 复杂）
4. 空间、时间的更多优化

## 复杂度和空间压缩技巧

动态规划表的大小：==每个可变参数的可能性数量相乘==

动态规划方法的时间复杂度：==动态规划表的大小 * 每个格子的枚举代价==

二维动态规划依然需要去整理动态规划表的格子之间的==依赖关系==

找寻依赖关系，往往通过画图来建立空间感，使其更显而易见

然后依然是==从简单格子填写到复杂格子==的过程，即严格位置依赖的动态规划（从底到顶）

二维动态规划的压缩空间技巧原理不难，会了之后千篇一律

但是不同题目依赖关系不一样，需要很细心的画图来整理具体题目的依赖关系，最后进行空间压缩的实现

## 什么样的递归可以改成动态规划？

能改成动态规划的递归，统一特征：

决定返回值的可变参数类型往往都比较简单，一般不会比 `int` 类型更复杂。为什么？

从这个角度，可以解释带路径的递归（即：回溯）（可变参数类型复杂），不适合或者说没有必要改成动态规划：

- 路径往往是整个表的状态
- 整个表的状态怎么表示？
- 就算能表示，情况那么多，动态规划表空间爆炸，时间也和动态规划表大小挂钩

[[#题目2.单词搜索|题目 2]] 就是说明这一点的

一定要写出==可变参数类型简单==（不比 `int` 类型更复杂），并且==可以完全决定返回值==的递归，保证做到这些可变参数可以完全代表之前决策过程对后续过程的影响！再去改动态规划！

不管几维动态规划

经常从递归的定义出发，避免后续进行很多边界讨论

这需要一定的经验来预知

## 备注

二维动态规划问题非常多，不仅本节和下节涉及，整个系列课程会大量涉及

【必备】课程后续会讲背包 dp、区间 dp、状压 dp 等等，依然包含大量二维动态规划问题

# 题目1.最小路径和

二维动态规划入门

## 题目描述

给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例 1：

![[Pasted image 20240201152452.png]]

>输入：`grid = [[1,3,1],[1,5,1],[4,2,1]]`
>
>输出：`7`
>
>解释：因为路径 `1 → 3 → 1 → 1 → 1` 的总和最小。

提示：

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `0 <= grid[i][j] <= 200`

## 测试链接

[64.最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

## 暴力递归

```go
var (
	theGrid [][]int
)

func minPathSum(grid [][]int) int {
	theGrid = grid
	n := len(grid)
	m := len(grid[0])
	return f(n-1, m-1) // 递归逆推
}

func f(i, j int) int {
	// base case
	if i == 0 && j == 0 {
		return theGrid[0][0]
	}

	up := math.MaxInt
	left := math.MaxInt
	if i-1 >= 0 {
		// 向上
		up = f(i-1, j)
	}
	if j-1 >= 0 {
		// 向左
		left = f(i, j-1)
	}
	return theGrid[i][j] + min(up, left)
}
```

## 记忆化搜索

```go
var (
	theGrid [][]int
	cache   [][]int
)

func minPathSum(grid [][]int) int {
	theGrid = grid
	n := len(grid)
	m := len(grid[0])
	cache = make([][]int, n)
	for i := range cache {
		cache[i] = make([]int, m)
		for j := 0; j < m; j++ {
			cache[i][j] = -1
		}
	}
	return f(n-1, m-1)
}

func f(i, j int) int {
	if cache[i][j] != -1 {
		return cache[i][j]
	}
	ans := 0
	// base case
	if i == 0 && j == 0 {
		ans = theGrid[0][0]
	} else {
		up := math.MaxInt
		left := math.MaxInt
		if i-1 >= 0 {
			// 向上
			up = f(i-1, j)
		}
		if j-1 >= 0 {
			// 向左
			left = f(i, j-1)
		}
		ans = theGrid[i][j] + min(up, left)
	}
	cache[i][j] = ans
	return ans
}
```

## 动态规划

```go
func minPathSum(grid [][]int) int {
	n := len(grid)
	m := len(grid[0])
	dp := make([][]int, n)
	for i := range dp {
		dp[i] = make([]int, m)
	}
	dp[0][0] = grid[0][0]
	for i := 1; i < n; i++ {
		dp[i][0] = grid[i][0] + dp[i-1][0]
	}
	for j := 1; j < m; j++ {
		dp[0][j] = grid[0][j] + dp[0][j-1]
	}
	for i := 1; i < n; i++ {
		for j := 1; j < m; j++ {
			dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
		}
	}
	return dp[n-1][m-1]
}
```

## 空间压缩

每个位置只依赖其上边单元格和左边单元格，运用滚动数组技巧，将二维 dp 数组压缩成一维

注意：只是对 dp 数组位置进行了复用，其整体思路和时间复杂度和二维 dp 数组是一样的

```go
func minPathSum(grid [][]int) int {
	n := len(grid)
	m := len(grid[0])
	dp := make([]int, m)
	dp[0] = grid[0][0]
	for j := 1; j < m; j++ {
		dp[j] = grid[0][j] + dp[j-1]
	}
	for i := 1; i < n; i++ {
		dp[0] += grid[i][0]
		for j := 1; j < m; j++ {
			// min(dp[j] /* 上 */, dp[j-1] /* 左 */)
			dp[j] = grid[i][j] + min(dp[j], dp[j-1])
		}
	}
	return dp[m-1]
}
```

# 题目2.单词搜索

无法改成动态规划

## 题目描述

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例 1：

![[Pasted image 20240201161600.png]]

>输入：`board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"`
>
>输出：`true`

提示：

- `m == board.length`
- `n = board[i].length`
- `1 <= m, n <= 6`
- `1 <= word.length <= 15`
- `board` 和 `word` 仅由大小写英文字母组成

## 测试链接

[79.单词搜索](https://leetcode.cn/problems/word-search/)

## 思路

要使用回溯算法，无法使用动态规划

## 答案

```go
var (
	theBoard [][]byte
	theWord  string
	n        int
	m        int
	w        int
)

func exist(board [][]byte, word string) bool {
	theBoard = board
	theWord = word
	n = len(board)
	m = len(board[0])
	w = len(word)
	for i := 0; i < n; i++ {
		for j := 0; j < m; j++ {
			if f(i, j, 0) {
				return true
			}
		}
	}
	return false
}

// 从 board[i][j] 出发，匹配 word[i:]
func f(i, j, k int) bool {
	if k == w {
		return true
	}
	if i < 0 || i == n || j < 0 || j == m || theBoard[i][j] != theWord[k] {
		return false
	}
	char := theBoard[i][j]
	// 因为 board 会改其中的字符，用来标记哪些字符无法再用
	// 所以带路径的递归（回溯）无法改成动态规划或者说没必要
	// board 状态不是简单可变参数，强行建 dp 状态表会很大，会适得其反
	// 甚至远远差于回溯
	theBoard[i][j] = 0 // 在一次尝试中，防止重复使用
	ans := f(i-1, j, k+1) ||
		f(i+1, j, k+1) ||
		f(i, j-1, k+1) ||
		f(i, j+1, k+1)
	theBoard[i][j] = char // 回溯状态，不要干扰下次尝试
	return ans
}
```
