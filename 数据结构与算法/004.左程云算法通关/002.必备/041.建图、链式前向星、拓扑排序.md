---
date: 2024-01-05 16:08
modified: 2024-01-05 17:16
---

>前置知识：[[013.队列和栈-链表、数组实现#^2|数组实现队列]]、[[001.算法笔试中处理输入和输出#临时动态空间 VS. 全局静态空间|算法笔试更推荐静态空间的方式]]、[[007.堆结构和堆排序#堆结构|堆结构]]

# 图

有向 VS. 无向（无向可以理解为双向）

不带权 VS. 带权

入参一般为==节点数量和所有的边==或者==直接给图==

建图的三种方式，我们图解一下

## 邻接矩阵

适合点的数量不多的图

需要的空间：$n^2$，$n$ 为节点数量

`matrix[a][b]` 表示 `a` 指向 `b` 的路

- 无向：将 `matrix[a][b]` 和 `matrix[b][a]` 都设置上值，相当于双向
	- 沿正对角线（左上-右下）对称
- 不带权：可以用 `1` 或 `true` 代表有路，`0` 或 `false` 代表无路
- 带权：用权值代表有路，`math.MaxInt` 或 `math.MinInt` 或 `0` 代表无路

![[邻接矩阵.excalidraw]]

```go
package main

import "fmt"

const (
	MAXN = 11
)

var (
	// 邻接矩阵方式建图
	graph = [MAXN][MAXN]int{}
)

func main() {
	// 有向有权
	// 点的编号为 1~n
	n := 4
	// [from, to, 权]
	edges1 := [][]int{
		{1, 3, 6},
		{4, 3, 4},
		{2, 4, 2},
		{1, 2, 7},
		{2, 3, 5},
		{3, 1, 1},
	}
	build(n)
	directGraph(edges1)
	print(n)
	fmt.Println("-----------")

	// 无向无权
	// [from, to]
	edges2 := [][]int{
		{1, 3},
		{4, 3},
		{2, 4},
		{1, 2},
		{2, 3},
	}
	build(n)
	undirectGraph(edges2)
	print(n)
}

// 邻接矩阵清空
func build(n int) {
	for i := 1; i <= n; i++ {
		for j := 1; j <= n; j++ {
			graph[i][j] = 0
		}
	}
}

// 有向图
func directGraph(edges [][]int) {
	for _, edge := range edges {
		graph[edge[0]][edge[1]] = edge[2]
	}
}

// 无向图
func undirectGraph(edges [][]int) {
	for _, edge := range edges {
		graph[edge[0]][edge[1]] = 1
		graph[edge[1]][edge[0]] = 1
	}
}

func print(n int) {
	for i := 1; i <= n; i++ {
		for j := 1; j <= n; j++ {
			fmt.Printf("%d ", graph[i][j])
		}
		fmt.Println()
	}
}
```

```text
0 7 6 0 
0 0 5 2 
1 0 0 0 
0 0 4 0 
-----------
0 1 1 0 
1 0 1 1 
1 1 0 1 
0 1 1 0 
```

## 邻接表

最常用的方式

需要的空间：$m$，$m$ 为边的数量

`table[a][b]` 表示 `a` 指向 `b` 的路

- 无向：将 `table[a][b]` 和 `table[b][a]` 都设置上值，相当于双向
- 不带权：`b` 为下标，`table[a]` 中有 `b` 代表有路，没 `b` 代表没路
- 带权：`b` 为下标 + 权重

![[邻接表.excalidraw]]

```go
package main

import "fmt"

var (
	// 邻接表方式建图
	graph = [][][2]int{}
)

func main() {
	// 有向有权
	// 点的编号为 1~n
	n := 4
	// [from, to, 权]
	edges1 := [][]int{
		{1, 3, 6},
		{4, 3, 4},
		{2, 4, 2},
		{1, 2, 7},
		{2, 3, 5},
		{3, 1, 1},
	}
	build(n)
	directGraph(edges1)
	print(n)

	// 无向、无权：略
}

// 邻接表重建
func build(n int) {
	graph = make([][][2]int, n+1)
	for i := 1; i <= n; i++ {
		graph[i] = [][2]int{}
	}
}

// 有向图
func directGraph(edges [][]int) {
	for _, edge := range edges {
		graph[edge[0]] = append(graph[edge[0]], [2]int{edge[1], edge[2]})
	}
}

func print(n int) {
	for i := 1; i <= n; i++ {
		fmt.Printf("%d: ", i)
		for _, v := range graph[i] {
			fmt.Printf("(%d,%d), ", v[0], v[1])
		}
		fmt.Println()
	}
}
```

```text
1: (3,6), (2,7), 
2: (4,2), (3,5), 
3: (1,1), 
4: (3,4), 
```

## 链式前向星

[[#邻接表|邻接表]] 使用动态结构，空间要求严苛情况下使用链式前向星。比赛必用，大厂笔试、面试不常用

## 备注

【必备】课程里涉及图的内容：

建图、链式前向星、拓扑排序、最小生成树、bfs、双向广搜

最短路（Dijkstra、A*、Floyd、Bellman-Ford、SPFA）

【挺难】课程里涉及图的内容：

基环树、欧拉回路、割点和桥、强连通分量、双连通分量、最大流、费用流、二分图的最大匹配
