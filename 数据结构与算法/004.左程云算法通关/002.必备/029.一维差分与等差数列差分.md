---
date: 2023-12-28 11:23
modified: 2023-12-28 17:29
---

>前置知识：无，知道什么是数组就行

# 一维差分

## 问题描述

有一个一维 `int` 数组，要对其进行多次范围操作，如果每次操作都修改每个位置的元素，就比较慢；可以用一维差分方法来做：每次操作只修改几个位置的元素，最后将所有位置刷对

比如有一个数组 `[0, 0, 0, 0, 0, 0, 0, 0, 0]`，要对其进行一系列操作：

1. `[2, 5] +3`
2. `[1, 6] -2`
3. `[4, 7] +5`

普通方法：

```text
arr           [0,  0,  0,  0,  0,  0,  0,  0,  0]
idx            0   1   2   3   4   5   6   7   8
[2, 5] +3     [        3,  3,  3,  3,           ]
[1, 6] -2     [   -2,  1,  1,  1,  1, -2,       ]
[4, 7] +5     [   -2,  1,  1,  6,  6,  3,  5,   ]
              [0, -2,  1,  1,  6,  6,  3,  5,  0]
```

## 一维差分的过程

- `set` 方法：`[L, R]+V`，`L 位置 +V, R+1 位置 -V`
	- 可以理解为效果从 `L` 开始生效，到 `R+1` 失效
	- `R+1` 越界就不用设置了，因为后序没有元素了，设置了也没有意义
- `build` 方法：从左往右累加前缀和

```text
arr           [0,  1,  2,  3,  4,  5,  6,  7,  8]
idx            0   1   2   3   4   5   6   7   8

set:
[2, 5] +3     [        3,             -3,       ]
[1, 6] -2     [   -2,  3,             -3,  2,   ]
[4, 7] +5     [   -2,  3,      5,     -3,  2, -5]

build:
              [0, -2,  3,  0,  5,  0, -3,  2, -5]
              [0, -2,  1,  1,  6,  6,  3,  5,  0]
```

[[#题目1.航班预订统计|题目]]

## 备注

一维差分很简单，没有理解难度

- 它不支持边操作、边查询（边操作、边查询用一维差分没有意义，还不如普通方法）
- 边操作、边查询用线段树、树状数组

# 等差数列差分

## 问题描述

一开始 $1\backsim n$ 范围上的数字都是 0。接下来一共有 $m$ 个操作。

每次操作：$l\backsim r$ 范围上依次加上首项 $s$、末项 $e$、公差 $d$ 的数列

最终 $1\backsim n$ 范围上的每个数字都要正确得到

## 等差数列差分的过程

1. 每个操作调用 `set` 方法
2. 所有操作完成后在 `arr` 上生成两遍前缀和，即调用 `build` 方法

```go
func set(l, r, s, e, d int) {
	arr[l] += s
	arr[l+1] += d-s
	arr[r+1] -= d+e
	arr[r+2] += e
}

func build() {
	// 两次前缀和
	for i := 1; i < len(arr); i++ {
		arr[i] += arr[i-1]
	}
	for i := 1; i < len(arr); i++ {
		arr[i] += arr[i-1]
	}
}
```

## 解释

拿 $1\backsim 5$ 范围上依次加上首项 $s$、末项 $e$、公差 $d$ 的数列举例，从最终结果逆推证明 `set` 函数为何这样设置

![[等差数列差分举例解释.excalidraw]]

只是为了理解，实际直接记忆即可

## 备注

等差数列差分在大厂笔试、面试中还不常见，是比赛必备技巧，但预计会流行

二维差分会在后续的【必备】课程里进一步讲述，支持边操作、边查询的结构会在【扩展】课程讲述

# 题目1.航班预订统计

## 题目描述

这里有 `n` 个航班，它们分别从 `1` 到 `n` 进行编号。

有一份航班预订表 `bookings` ，表中第 `i` 条预订记录 `bookings[i] = [firsti, lasti, seatsi]` 意味着在从 `firsti` 到 `lasti` （**包含** `firsti` 和 `lasti` ）的 **每个航班** 上预订了 `seatsi` 个座位。

请你返回一个长度为 `n` 的数组 `answer`，里面的元素是每个航班预定的座位总数。

## 测试链接

[1109.航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)

## 答案

```go
func corpFlightBookings(bookings [][]int, n int) []int {
	// 为了方便书写，0 位置不用，最后一个位置防止 R+1 越界
	ans := make([]int, n+2)
	for _, booking := range bookings {
		ans[booking[0]] += booking[2]
		ans[booking[1]+1] -= booking[2]
	}
	// 加工前缀和
	for i := 1; i < n+2; i++ {
		ans[i] += ans[i-1]
	}
	return ans[1 : n+1]
}
```

# 题目2.等差数列差分模板

## 题目描述

一开始 $1\backsim n$ 范围上的数字都是 0，一共有 $m$ 个操作，每次操作为 $(l,r,s,e,d)$ 表示在 $l\backsim r$ 范围上依次加上首项为 $s$、末项为 $e$、公差为 $d$ 的数列

$m$ 个操作做完之后，统计 $1\backsim n$ 范围上所有数字的异或和和最大值

## 测试链接

[P4231 三步必杀](https://www.luogu.com.cn/problem/P4231)

## 答案

```golang
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

const (
	MAXN = 10000005
)

var (
	arr = [MAXN]int{}
	n   int
	m   int
)

func main() {
	in := bufio.NewScanner(os.Stdin)
	out := bufio.NewWriterSize(os.Stdout, 4096)
	for in.Scan() {
		tmp := strings.Fields(in.Text())
		n, _ = strconv.Atoi(tmp[0])
		m, _ = strconv.Atoi(tmp[1])
		for ; m > 0; m-- {
			in.Scan()
			tmp = strings.Fields(in.Text())
			l, _ := strconv.Atoi(tmp[0])
			r, _ := strconv.Atoi(tmp[1])
			s, _ := strconv.Atoi(tmp[2])
			e, _ := strconv.Atoi(tmp[3])
			d := (e - s) / (r - l)
			set(l, r, s, e, d)
		}
		build()
		xor := 0
		maxx := 0
		for i := 1; i <= n; i++ {
			xor ^= arr[i]
			maxx = max(maxx, arr[i])
		}
		fmt.Fprintln(out, xor, maxx)
	}
	out.Flush()
}

func set(l, r, s, e, d int) {
	arr[l] += s
	arr[l+1] += d - s
	arr[r+1] -= d + e
	arr[r+2] += e
}

func build() {
	for i := 1; i <= n; i++ {
		arr[i] += arr[i-1]
	}
	for i := 1; i <= n; i++ {
		arr[i] += arr[i-1]
	}
}
```
