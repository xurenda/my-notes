---
date: 2023-12-29 13:46
modified: 2023-12-29 13:51
---

>前置知识：[[049.从递归入手二维动态规划|从递归入手二维动态规划]]

本节课不再从递归入手，而是直接从动态规划的定义入手，来见识更多二维动态规划问题

本节课包含一些比较巧妙的尝试思路

[[049.从递归入手二维动态规划#备注|备注]]

# 题目1.不同的子序列

## 题目描述

给你两个字符串 `s` 和 `t`，统计并返回在 `s` 的 **子序列** 中 `t` 出现的个数，结果需要对 `10^9+7` 取模。

提示：

- `1 <= s.length, t.length <= 1000`
- `s` 和 `t` 由英文字母组成

## 测试链接

[115.不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

## 动态规划

```go
func numDistinct(s string, t string) int {
	sLen, tLen := len(s), len(t)
	// dp[i][j]：s[前缀长度为 i] 的所有子序列中，有多少个子序列等于 t[前缀长度为 j]
	dp := make([][]int, sLen+1)
	for i := range dp {
		dp[i] = make([]int, tLen+1)
		dp[i][0] = 1 // t 长度为 0：一个子序列，为空串
		// dp[0][j] = 0
	}
	for i := 1; i <= sLen; i++ {
		for j := 1; j <= tLen; j++ {
			dp[i][j] = dp[i-1][j] // 不要 s[i-1] 的字符
			if s[i-1] == t[j-1] {
			    // 要 s[i-1] 的字符，相等才能要
				dp[i][j] += dp[i-1][j-1] // s[i-1] 位置搞定了，之前位置怎么样？
			}
		}
	}
	return dp[sLen][tLen]
}
```

## 空间压缩

一个格子依赖上和左上格子

滚动行，从上往下，从右往左填格子

```go
func numDistinct(s string, t string) int {
	sLen, tLen := len(s), len(t)
	dp := make([]int, tLen+1)
	dp[0] = 1
	for i := 1; i <= sLen; i++ {
		for j := tLen; j >= 1; j-- {
			if s[i-1] == t[j-1] {
				dp[j] += dp[j-1]
			}
		}
	}
	return dp[tLen]
}
```

# 题目2.编辑距离

工程上非常常用的一个算法，非常重要的一个算法，用来评价两个字符串的相似程度

## 题目描述

给你两个单词 `word1` 和 `word2`，返回将 `word1` 转换成 `word2` 所使用的最少代价

你可以对一个单词进行如下三种操作：

- 插入一个字符，代价 `a`
- 删除一个字符，代价 `b`
- 替换一个字符，代价 `c`

leetcode 这道题是一个阉割版本：`a`、`b`、`c` 都是 1

## 测试链接

[72.编辑距离](https://leetcode.cn/problems/edit-distance/)

## 思路

## 答案

## 复杂度
