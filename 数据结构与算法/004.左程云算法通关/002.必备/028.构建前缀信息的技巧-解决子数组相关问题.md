---
date: 2023-12-27 16:49
modified: 2023-12-27 17:29
---

>前置知识：[[008.哈希表、有序表和比较器的用法#哈希表的用法|哈希表的用法]]

对输入数据进行预处理是一个很重要的技巧，构建前缀信息正是其中之一

解决如下问题，时间复杂度 $O(n)$

# 题目1.构建前缀和数组

构建前缀和数组，快速解决子数组范围求和的问题

## 题目描述

给定一个整数数组  `nums`，处理以下类型的多个查询：计算索引 `left` 和 `right` （包含 `left` 和 `right`）之间的 `nums` 元素的 **和** ，其中 `left <= right`

实现 `NumArray` 类：

- `NumArray(int[] nums)` 使用数组 `nums` 初始化对象
- `int sumRange(int i, int j)` 返回数组 `nums` 中索引 `left` 和 `right` 之间的元素的 **总和** ，包含 `left` 和 `right` 两点（也就是 `nums[left] + nums[left + 1] + ... + nums[right]` )

## 测试链接

[303.区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)

## 答案

```go
type NumArray []int

func Constructor(nums []int) NumArray {
	// 前缀和数组：sum[i] 表示 nums[:i] 的和
	// 最前面加一个 0，为了省去 left = 0 时的边界讨论
	// 不加的话可以在原数组上累加，省了 O(n) 的空间复杂度
	// 但是需要边界讨论，更重要的是修改了原数组，构造函数不应该修改传入的参数
	sum := make([]int, len(nums)+1)
	for i, num := range nums {
		sum[i+1] = sum[i] + num
	}
	return NumArray(sum)
}

func (this NumArray) SumRange(left int, right int) int {
	return this[right+1] - this[left]
}

/**
 * Your NumArray object will be instantiated and called as such:
 * obj := Constructor(nums);
 * param_1 := obj.SumRange(left,right);
 */
```

# 题目2.构建前缀和最早出现的位置

构建前缀和最早出现的位置，返回无序数组中累加和为给定值的最长子数组长度

## 题目描述

给定一个无序数组 `arr`, 其中元素可正、可负、可 0。给定一个整数 `k`，求 `arr` 所有子数组中累加和为 `k` 的最长子数组长度

## 测试链接

[未排序数组中累加和为给定值的最长子数组长度](https://www.nowcoder.com/practice/36fb0fd3c656480c92b569258a1223d5)

## 答案

```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"unicode"
)

const (
	MAXN = 1e5
)

var (
	arr = [MAXN]int{}
	n   int
	k   int
	mp  map[int]int // 0-key 的前缀和最早出现在 val 索引处
)

func main() {
	in := bufio.NewScanner(os.Stdin)
	in.Split(splitWithSpace)
	out := bufio.NewWriterSize(os.Stdout, 4096)
	for in.Scan() {
		n, _ = strconv.Atoi(in.Text())
		in.Scan()
		k, _ = strconv.Atoi(in.Text())
		for i := 0; i < n; i++ {
			in.Scan()
			arr[i], _ = strconv.Atoi(in.Text())
		}
		// 牛客 go 版本太低，没有 clear 方法，只能重新建一个了
		// clear(mp)
		mp = map[int]int{}
		fmt.Fprintln(out, compute())
	}
	out.Flush()
}

func compute() int {
	ans := 0
	sum := 0
	// 重要: 0 这个前缀和，一个数字也没有的时候，就存在了
	mp[0] = -1
	for i := 0; i < n; i++ {
		sum += arr[i]
		if idx, has := mp[sum-k]; has {
			if i-idx > ans {
				ans = i - idx
			}
		}
		// 因为求最长，所有要记录最早出现的索引
		if _, has := mp[sum]; !has {
			mp[sum] = i
		}
	}
	return ans
}

func splitWithSpace(data []byte, atEOF bool) (advance int, token []byte, err error) {
	// 跳过连续的空白字符
	start := 0
	for start < len(data) && unicode.IsSpace(rune(data[start])) {
		start++
	}

	// 使用unicode.IsSpace来判断是否是空白字符
	for i := start; i < len(data); i++ {
		if unicode.IsSpace(rune(data[i])) {
			return i + 1, data[start:i], nil
		}
	}

	// 如果未找到空白字符，且已经到达文件末尾，返回剩余的内容
	if atEOF && len(data[start:]) > 0 {
		return len(data), data[start:], nil
	}

	// 如果未找到空白字符且未到达文件末尾，则要求继续读取更多数据
	return 0, nil, nil
}
```

# 题目3.构建前缀和出现的次数

构建前缀和出现的次数，返回无序数组中累加和为给定值的子数组数量

题目4 : 构建 前缀和 最早出现的位置。返回 无序数组中 正数和负数个数相等的 最长子数组长度

题目5 : 构建 前缀和 最早出现的位置。表现良好的最长时间段问题

题目6 : 构建 前缀和余数 最晚出现的位置。移除的最短子数组长度，使得剩余元素的累加和能被p整除

题目7 : 构建 前缀奇偶状态 最早出现的位置。每个元音包含偶数次的 最长子串长度

构建某个前缀信息 最早出现、最晚出现、出现次数等，是很常见的技巧

除此之外，还有很多种类的前缀信息可以构建出来，解决很多子数组相关问题

更多题目会在 题目系列 里见到，欢迎持续关注、转发，下节见！