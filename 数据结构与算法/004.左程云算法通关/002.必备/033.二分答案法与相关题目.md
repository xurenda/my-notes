---
date: 2023-12-29 13:46
modified: 2023-12-29 13:51
---

>前置知识：[[006.二分搜索|基本二分搜索]]、[[005.对数器-验证的重要手段|对数器]]、[[024.对数器打表找规律的技巧|进一步了解对数器]]

# 二分答案法

1. 估计==最终答案可能的范围==是什么，可以定的粗略，反正二分不了几次
2. 分析==问题的答案==和==给定条件==之间的单调性，大部分时候只需要用到自然智慧
3. 建立一个 `f` 函数，当答案固定的情况下，判断给定的条件是否达标
4. 在最终答案可能的范围上不断二分搜索，每次用 `f` 函数判断，直到二分结束，找到最合适的答案

核心点：分析单调性、建立 `f` 函数

注意：这个技巧常用且重要，一定要引起重视，非常的美、精妙！以后的课还会经常见到

# 题目1.爱吃香蕉的珂珂

## 题目描述

珂珂喜欢吃香蕉。这里有 `n` 堆香蕉，第 `i` 堆中有 `piles[i]` 根香蕉。警卫已经离开了，将在 `h` 小时后回来。

珂珂可以决定她吃香蕉的速度 `k` （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 `k` 根。如果这堆香蕉少于 `k` 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  

珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。

返回她可以在 `h` 小时内吃掉所有香蕉的最小速度 `k`（`k` 为整数）。

提示：

- `1 <= piles.length <= 10^4`
- `piles.length <= h <= 10^9`
- `1 <= piles[i] <= 10^9`

## 测试链接

[875.爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/)

## 思路

> [!note] 估计最终答案可能的范围是什么
> 最少：一个小时吃 1 根
> 
> 最多：一个小时吃 `piles` 最大值根，因为吃更快也没用了，一个小时最多吃一堆

> [!note] 分析问题的答案和给定条件之间的单调性
> 吃的越快，越容易在警卫回来前吃完

> [!note] 建立一个 `f` 函数，当答案固定的情况下，判断给定的条件是否达标
> 输入吃的速度，返回吃完所有香蕉花的时间

## 答案

```go
func minEatingSpeed(piles []int, h int) int {
	// if h < len(piles) {
	// 	panic("没有答案")
	// }
	// 答案必定在 [l, r] 中
	l := 1
	r := 0 // max
	for _, num := range piles {
		r = max(r, num)
	}
	ans := 0
	for l <= r {
		m := l + (r-l)>>1
		if f(piles, m) <= h {
			// 达标！记录答案
			ans = m
			r = m - 1
		} else {
			// 不达标
			l = m + 1
		}
	}
	return ans
}

// piles: 香蕉重量
// speed: 吃香蕉的速度
// 返回吃完所有的香蕉，耗费的时间
func f(piles []int, speed int) int {
	ans := 0
	for _, num := range piles {
		// a / b 想向上取整，可以写成: (a+b-1) / b
	    // 前提是 a 和 b 都是非负数
		ans += (num + speed - 1) / speed
	}
	return ans
}
```

## 复杂度

- 时间复杂度：$O(n*log^{max})$，`f`：$O(n)$，二分：$O(log^{max})$
- 空间复杂度：$O(1)$

# 题目2.分割数组的最大值(画匠问题)

## 题目描述

给定一个非负整数数组 `nums` 和一个整数 `k` ，你需要将这个数组分成 `k` 个非空的连续子数组。

设计一个算法使得这 `k` 个子数组各自和的最大值最小。

## 测试链接

[410.分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/)

## 思路

> [!note] 估计最终答案可能的范围是什么
> 最少：数组最大值，因为子数组要求非空
> 
> 最多：数组累加和

> [!note] 分析问题的答案和给定条件之间的单调性
> 分成的子数组越多，每一个子数组的累加和最大值越小

> [!note] 建立一个 `f` 函数，当答案固定的情况下，判断给定的条件是否达标
> 输入每一子数组的累加和要 `<= limit`，返回需要分成几个子数组

## 答案

```go
func splitArray(nums []int, k int) int {
	l := 0 // max
	r := 0 // sum
	for _, num := range nums {
		l = max(l, num)
		r += num
	}
	ans := 0
	for l <= r {
		m := l + (r-l)>>1
		if f(nums, m) <= k {
			ans = m
			r = m - 1
		} else {
			l = m + 1
		}
	}
	return ans
}

// limit: 每一子数组的累加和要 <= limit
// 返回需要分成几个子数组
func f(nums []int, limit int) int {
	ans := 1
	sum := 0
	for _, num := range nums {
		if num > limit {
			return math.MaxInt // 分不出来
		}
		sum += num
		if sum > limit {
			ans++
			sum = num
		}
	}
	return ans
}
```

## 复杂度

- 时间复杂度：$O(n*log^{sum-max})$，`f`：$O(n)$，二分：$O(log^{sum-max})$
- 空间复杂度：$O(1)$

# 题目3.机器人跳跃问题

## 题目描述

机器人正在玩一个古老的基于 DOS 的游戏。游戏中有 `N+1` 座建筑——从 0 到 `N` 编号，从左到右排列。编号为 0 的建筑高度为 0 个单位，编号为 `i` 的建筑的高度为 `H(i)`个单位。 

起初， 机器人在编号为 0 的建筑处。每一步，它跳到下一个（右边）建筑。假设机器人在第 `k` 个建筑，且它现在的能量值是 `E`, 下一步它将跳到第个 `k+1` 建筑。它将会得到或者失去正比于与 `H(k+1)` 与 `E` 之差的能量。如果 `H(k+1) > E` 那么机器人就失去 `H(k+1) - E` 的能量值，否则它将得到 `E - H(k+1)` 的能量值。

游戏目标是到达第个 `N` 建筑，在这个过程中，能量值不能为负数个单位。现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏？

## 测试链接

[机器人跳跃问题](https://www.nowcoder.com/practice/7037a3d57bbd4336856b8e16a9cafd71)

## 思路

> [!note] 估计最终答案可能的范围是什么
> 最少初始能量：0，建筑高度都是 0 的情况下
> 
> 最多初始能量：建筑高度最大值

> [!note] 分析问题的答案和给定条件之间的单调性
> 初始能量越多（得到的能量多、失去的能量少）越容易到达最后一个建筑

> [!note] 建立一个 `f` 函数，当答案固定的情况下，判断给定的条件是否达标
> 输入初始能量，返回能否到达最后一个建筑

一个坑：能量值增长可能会溢出 `int` 范围，加一个与最高建筑比较的判断，一可以防止溢出导致答案错误；二可以剪枝，提前返回可以到达最后一个建筑

## 答案

```go
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
)

const (
	MAXN = 1e5 + 1
)

var (
	arr  = [MAXN]int{}
	n    int
	maxx int // 数组最大值
)

func main() {
	in := bufio.NewScanner(os.Stdin)
	in.Split(bufio.ScanWords)
	out := bufio.NewWriterSize(os.Stdout, 4096)
	for in.Scan() {
		n, _ = strconv.Atoi(in.Text())
		maxx = 0
		for i := 0; i < n; i++ {
			in.Scan()
			arr[i], _ = strconv.Atoi(in.Text())
			maxx = max(maxx, arr[i])
		}
		l := 0
		r := maxx
		m := 0
		ans := 0
		for l <= r {
			m = l + (r-l)>>1
			if f(m) {
				ans = m
				r = m - 1
			} else {
				l = m + 1
			}
		}
		fmt.Fprintln(out, ans)
	}
	out.Flush()
}

// energy: 初始能量
// 返回能否到达最后一个建筑
func f(energy int) bool {
	for i := 0; i < n; i++ {
		if energy > arr[i] {
			energy += energy - arr[i]
		} else {
			energy -= arr[i] - energy
		}
		// 1. 剪枝: 当前能力比最高建筑都大，必定能到达最后一个建筑
		// 2. 防止能量 int 溢出: 能量一直加，可能溢出 int 范围，导致结果错误
		if energy >= maxx {
			return true
		}
		if energy < 0 {
			return false
		}
	}
	return true
}

// 牛客 go 版本太低，没有内置的 max 函数
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

## 复杂度

- 时间复杂度：$O(n*log^{max})$，`f`：$O(n)$，二分：$O(log^{max})$
- 空间复杂度：$O(1)$

# 题目4.找出第 K 小的数对距离

## 题目描述

数对 `(a,b)` 由整数 `a` 和 `b` 组成，其数对距离定义为 `a` 和 `b` 的绝对差值。

给你一个整数数组 `nums` 和一个整数 `k` ，数对由 `nums[i]` 和 `nums[j]` 组成且满足 `0 <= i < j < nums.length` 。返回 **所有数对距离中** 第 `k` 小的数对距离。

示例 1：

>输入：`nums = [1,3,1], k = 1`
>
>输出：`0`
>
>解释：数对和对应的距离如下：
>
>`(1,3) -> 2`
>
>`(1,1) -> 0`
>
>`(3,1) -> 2`
>
>距离第 `1` 小的数对是 `(1,1)`，距离为 `0`

示例 2：

>输入：`nums = [1,1,1], k = 2`
>
>输出：`0`

示例 3：

>输入：`nums = [1,6,1], k = 3`
>
>输出：`5`

提示：

- `n == nums.length`
- `2 <= n <= 10^4`
- `0 <= nums[i] <= 10^6`
- `1 <= k <= n * (n - 1) / 2`

## 测试链接

[719.找出第 K 小的数对距离](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)

## 思路

> [!note] 估计最终答案可能的范围是什么
> 最小数对距离：0
> 
> 最大数对距离：`max - min`

> [!note] 分析问题的答案和给定条件之间的单调性
> 数对限制距离越大，能得到更多的数对个数符合 `<=` 限制距离

> [!note] 建立一个 `f` 函数，当答案固定的情况下，判断给定的条件是否达标
> 输入 `arr` 中任意两数的差值 `<= limit`，返回有几个符合要求的数对

## 答案

```go
func smallestDistancePair(nums []int, k int) int {
	ans := 0
	sort.Ints(nums) // 为了 f 的滑动窗口
	n := len(nums)
	minn := nums[0]
	maxx := nums[n-1]
	l := 0
	r := maxx - minn
	m := 0
	for l <= r {
		m = l + (r-l)>>1
		if f(nums, m) >= k {
			ans = m
			r = m - 1
		} else {
			l = m + 1
		}
	}
	return ans
}

// arr 升序排列
// arr 中任意两数的差值 <= limit
// 这样的数字配对，有几对？
func f(arr []int, limit int) int {
	n := len(arr)
	ans := 0
	// 滑动窗口，收集以 l 开头的答案
	r := 1
	for l := 0; l < n; l++ {
		for r != n && arr[r]-arr[l] <= limit {
			r++
		}
		ans += r - l - 1
	}
	return ans
}
```

## 复杂度

- 时间复杂度：$O(n*log^n+n*log^{max-min})$，排序：$O(n*log^n)$，`f`（滑动窗口）：$O(n)$，二分：$O(log^{max-min})$
- 空间复杂度：$O(1)$
