---
date: 2023-12-29 13:46
modified: 2024-03-13 17:32
---

>前置知识：[[003.二进制和位运算|讲解003]]、[[012.异或运算的骚操作|讲解030]]、[[013.位运算的骚操作|讲解031]]、[[014.位图|讲解032]]、[[015.位运算实现加减乘除|讲解033]] 位运算基础、[[025.根据数据量猜解法的技巧-天字第一号重要技巧|根据数据量猜解法]]、[[045.双向广搜|双向广搜]]、[[049.从递归入手二维动态规划|从递归入手二维动态规划]]

本节课会讲述状压 dp 的原理以及 4 个题目，其中包括大名鼎鼎的 TSP 问题（题目 4）

下节课会见识更多状压 dp 问题 & 更多技巧
# 状压 dp

状压 dp（状态压缩）：设计一个整型可变参数 `status`，利用 `status` 的==位信息==，来表示：某个样本是否还能使用，然后利用这个信息进行尝试（相当于带了简单的路径信息）

1. 写出尝试的递归函数
2. 记忆化搜索
3. 严格位置依赖的动态规划
4. 空间压缩等优化

## 数据量说明

如果有 `k` 个样本，那么表示这些样本的状态，数量是 `2^k`

所以可变参数 `status` 的范围： `0 ~ (2^k)-1`

样本每增加一个，状态的数量是指数级增长的，所以状压 dp 能解决的问题往往样本数据量都不大

一般样本数量在 20 个以内（$10^6$），如果超过这个数量，计算量（指令条数）会超过 `10^7 ~ 10^8`：[[025.根据数据量猜解法的技巧-天字第一号重要技巧|根据数据量猜解法的技巧-天字第一号重要技巧]]

如果样本数量大到状压 dp 解决不了，或者任何动态规划都不可行，那么 [[045.双向广搜|双向广搜]] 是一个备选思路

## 备注

轮廓线 dp 是状压 dp 中一类比较难的问题，【扩展】课程阶段讲述

插头 dp 是轮廓线 dp 中一类更难的问题，在笔试、面试中几乎没有出现的可能，不会安排。比赛同学自行学习

# 题目1.我能赢吗

## 题目描述

在 "100 game" 这个游戏中，两名玩家轮流选择从 `1` 到 `10` 的任意整数，累计整数和，先使得累计整数和 **达到或超过**  100 的玩家，即为胜者。

如果我们将游戏规则改为 “玩家 **不能** 重复使用整数” 呢？

例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 >= 100。

给定两个整数 `maxChoosableInteger` （整数池中可选择的最大数）和 `desiredTotal`（累计和），若先出手的玩家能稳赢则返回 `true` ，否则返回 `false` 。假设两位玩家游戏时都表现 **最佳** 。

示例 1：

>输入：`maxChoosableInteger = 10, desiredTotal = 11`
>
>输出：`false`
>
>解释：
>
>无论第一个玩家选择哪个整数，他都会失败。
>
>第一个玩家可以选择从 1 到 10 的整数。
>
>如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。
>
>第二个玩家可以通过选择整数 10（那么累积和为 11 >= `desiredTotal`），从而取得胜利.
>
>同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。

示例 2：

>输入：`maxChoosableInteger = 10, desiredTotal = 0`
>
>输出：`true`

示例 3：

>输入：`maxChoosableInteger = 10, desiredTotal = 1`
>
>输出：`true`

提示：

- `1 <= maxChoosableInteger <= 20`
- `0 <= desiredTotal <= 300`

## 测试链接

[464.我能赢吗](https://leetcode.cn/problems/can-i-win/)

## 答案

```go
var (
	n     int
	m     int
	cache []*bool
)

func canIWin(maxChoosableInteger int, desiredTotal int) bool {
	n = maxChoosableInteger
	m = desiredTotal
	if m == 0 {
		// 来自题目规定
		return true
	}
	if (n*(n+1))>>1 < m {
		// 如果 1~n 数字全加起来
		// 累加和是 n * (n+1) / 2，都小于 m
		// 那么不会有赢家，也就意味着先手不会获胜
		return false
	}
	// 0000...（n 个 0）~1111...（n 个 1）
	cache = make([]*bool, 1<<(n+1))
	return f(1<<(n+1)-1, m)
}

// 如果 1~7 范围的数字都能选，那么 status 的状态为：
// 1 1 1 1 1 1 1 1
// 7 6 5 4 3 2 1 0
// 0 位弃而不用
// 如果 1~7 范围的数字，4、2 已经选了不能再选，那么 status 的状态为：
// 1 1 1 0 1 0 1 1
// 7 6 5 4 3 2 1 0
// 0 位弃而不用
// f 的含义：
// 数字范围 1~n，当前的先手，面对 status 给定的数字状态
// 在累加和还剩 rest 的情况下
// 返回当前的先手能不能赢（当前的先手可能是玩家 1 也可能是玩家 2）
func f(status, rest int) bool {
	if rest <= 0 {
		return false
	}
	if cache[status] != nil {
		return *cache[status]
	}
	ans := false
	for i := 1; i <= n; i++ {
		// 考察所有数字，但是不能选择之前选了的数字
		// 并且下一个玩家要输
		if status&(1<<i) != 0 && !f(status^(1<<i), rest-i) {
			ans = true
			break
		}
	}
	cache[status] = &ans
	return ans
}
```

## 复杂度

- 时间复杂度：$O(2^n*n)$
	- $O(2^n)$：dp 表大小
	- $O(n)$：每个格子枚举代价
- 空间复杂度：$O(2^n)$

## 备注

这道题有两个可变参数：`status`、`rest`

但最关键的可变参数就 1 个，即 `status`，表示还有哪些数字可以使用

另一个可变参数 `rest` 是被 `status` 决定的，所以只需要对 `status` 做缓存表

任何动态规划都是这样！只关注最关键的可变参数，被决定的可变参数不用管！不重要！

# 题目2.火柴拼正方形

## 题目描述

你将得到一个整数数组 `matchsticks` ，其中 `matchsticks[i]` 是第 `i` 个火柴棒的长度。你要用 **所有的火柴棍** 拼成一个正方形。你 **不能折断** 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 **使用一次** 。

如果你能使这个正方形，则返回 `true` ，否则返回 `false` 。

示例 1：

![[Pasted image 20240313092138.png]]

>输入：`matchsticks = [1,1,2,2,2]`
>
>输出：`true`
>
>解释：能拼成一个边长为 2 的正方形。

示例 2：

>输入：`matchsticks = [3,3,3,3,4]`
>
>输出：`false`
>
>解释：不能用所有火柴拼成一个正方形。

提示：

- `1 <= matchsticks.length <= 15`
- `1 <= matchsticks[i] <= 10^8`

## 测试链接

[473.火柴拼正方形](https://leetcode.cn/problems/matchsticks-to-square/)

## 答案

[[002.背包问题#火柴拼正方形|火柴拼正方形]]

```go
var (
	nums  []int
	n     int
	limit int // 每条边的长度
	cache []*bool
)

func makesquare(matchsticks []int) bool {
	nums = matchsticks
	sum := 0
	for _, num := range nums {
		sum += num
	}
	// 剪枝：不能被 4 整除
	if sum%4 != 0 {
		return false
	}
	limit = sum / 4
	n = len(nums)
	cache = make([]*bool, 1<<n)
	return f(1<<n-1, 0, 4)
}

// status：哪些火柴没有用的位信息，1：没用；0：用了
// cur：当前要解决的这条边已经形成的长度
// rest：一共还有几条边没有解决
// 返回：能否用光所有火柴去解决剩下的所有边
// 因为调用子过程之前，一定保证每条边累加起来都不超过 limit
// 所以 status 是决定 cur 和 rest 的，关键可变参数只有 status
func f(status, cur, rest int) bool {
	// 火柴用完了，也没有剩下的边了
	if rest == 0 {
		return status == 0
	}
	if cache[status] != nil {
		return *cache[status]
	}
	ans := false
	for i := 0; i < n; i++ {
		// 考察每一根火柴，只能使用状态为 1 的火柴
		if status&(1<<i) != 0 && cur+nums[i] <= limit {
			if cur+nums[i] == limit {
				ans = f(status^(1<<i), 0, rest-1)
			} else {
				ans = f(status^(1<<i), cur+nums[i], rest)
			}
			if ans {
				break
			}
		}
	}
	cache[status] = &ans
	return ans
}
```

## 复杂度

- 时间复杂度：$O(2^n*n)$
	- $O(2^n)$：dp 表大小
	- $O(n)$：每个格子枚举代价
- 空间复杂度：$O(2^n)$
