---
date: 2023-12-29 13:46
modified: 2023-12-29 13:51
---

>前置知识：[[041.建图、链式前向星、拓扑排序|建图]]、[[044.宽度优先遍历及其扩展|宽度优先遍历]]、[[046.Dijkstra 算法、分层图最短路|Dijkstra 算法]]

注意：

【必备】标签下的课程，都是最基础、最高频的内容

有关图的更多内容，会在后续【扩展】、【挺难】标签下的课程中继续讲述

# `A*` 算法

指定源点，指定目标点，求源点到达目标点的最短距离（如：游戏 NPC 寻路算法）

与 [[046.Dijkstra 算法、分层图最短路#Dijkstra 算法|Dijkstra 算法]] 解决的问题差不多，只是 Dijkstra 是求所有点距原点的距离，`A*` 是只有一个目标点

那么 Dijkstra 也可以求（将其他无用点的结果舍弃即可），`A*` 也可以求？为什么非要用 `A*`，因为更快

与 Dijkstra 算法的思路也基本相同，只是增加了当前点到终点的预估函数，在堆中根据==从源点出发到达当前点的距离+当前点到终点的预估距离==来进行排序，剩下的所有细节和 Dijkstra 算法完全一致

预估函数要求：当前点到终点的预估距离 <= 当前点到终点的真实最短距离（否则可能导致答案错误）

可以理解预估函数是一种吸引力：

- 合适的吸引力可以提升算法的速度，吸引力过强会出现错误
- 保证预估距离 <= 真实最短距离的情况下，尽量接近真实最短距离，可以做到功能正确且最快

预估终点距离经常选择：

- 曼哈顿距离：$|x_0-x_1|+|y_0-y_1|$，只能走直线的情况
- 欧式距离：$\sqrt{(x_0-x_1)^2+(y_0-y_1)^2}$，即：勾股定理
- 对角线距离：$max(|x_0-x_1|, |y_0-y_1|)$，可以走对角线的情况

## 题目1. `A*` 算法模板

对数器验证，对比 Dijkstra 算法和 `A*` 算法的速度差异，以及不同预估函数的速度和正确性差异

### 题目描述

有一个二维网格 `grid`，它的每一个位置可能是 0（代表障碍）或 1（代表道路），求从 `start` 最少需要几步走到 `end`，只能向上下左右走

### 思路

### 答案

### 总结

这个问题可以用普通 bfs（或双向 bfs）来解决、Dijkstra 来解决、`A*` 来解决

Dijkstra 比普通 bfs 多了个堆，时间复杂度还多了 $log^n$ 的堆操作，但不用全展开

`A*` 和 Dijkstra 的时间复杂度是一样的，只是优化了常数时间，预估距离越接近真实最短距离，优化的常数时间越多（这道题曼哈顿距离比对角线距离更快）

但是要注意保证预估距离 <= 真实最短距离，否则答案是错误的！（比如这道题如果可以走斜线，那么曼哈顿距离就是错的）








# Floyd 算法

得到图中任意两点之间的最短距离

时间复杂度O(n^3)，空间复杂度O(n^2)，常数时间小，容易实现

适用于任何图，不管有向无向、不管边权正负、但是不能有负环（保证最短路存在）

过程简述:

distance[i][j]表示i和j之间的最短距离

distance[i][j] = min ( distance[i][j] , distance[i][k] + distance[k][j])

枚举所有的 k 即可，实现时一定要最先枚举跳板！

# Bellman-Ford 算法

解决可以有负权边但是不能有负环（保证最短路存在）的图，单源最短路算法

松弛操作

假设源点为A，从A到任意点F的最短距离为distance[F]

假设从点P出发某条边，去往点S，边权为W

如果发现，distance[P] + W < distance[S]，也就是通过该边可以让distance[S]变小

那么就说，P出发的这条边对点S进行了松弛操作

Bellman-Ford过程

1，每一轮考察每条边，每条边都尝试进行松弛操作，那么若干点的distance会变小

2，当某一轮发现不再有松弛操作出现时，算法停止
