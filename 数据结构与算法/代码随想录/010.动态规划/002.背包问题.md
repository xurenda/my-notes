![[背包问题分类.png]]
# 01 背包
- 416.分割等和子集
	- 相似题目
		- ==698.划分为 k 个相等的子集==
			- [[002.背包问题#划分为 k 个相等的子集 - 状态压缩 + 记忆化搜索|状态压缩 + 记忆化搜索]]
			- [[002.背包问题#划分为 k 个相等的子集 - 状态压缩 + 动态规划|状态压缩 + 动态规划]]
		- 473.火柴拼正方形
		- [[002.背包问题#完成所有工作的最短时间|1723.完成所有工作的最短时间]]
		- [[002.背包问题#公平分发饼干|2305.公平分发饼干]]（同上题）
			- [视频讲解](https://www.bilibili.com/video/BV1aT41157bh/)


# 划分为 k 个相等的子集 - 状态压缩 + 记忆化搜索
![[Pasted image 20231108111955.png]]

```go
var (
  theNums []int
  theAvg int
  theDp []bool
)

func canPartitionKSubsets(nums []int, k int) bool {
  sum := 0
  for _, num := range nums {
    sum += num
  }
  if sum % k != 0 {
    // 不能整除
    return false
  }
  avg := sum / k
  sort.Ints(nums)
  n := len(nums)
  if nums[n - 1] > avg {
    // 最大数比平均值大
    return false
  }

  // dp[S]: 数组可用状态为i时，是否可以划分为k个相等的子集
  // s: 位图，代表数组每一位的可用状态，1-可用，0-不可用
  dp := make([]bool, 1 << n)
  for i := range dp {
    dp[i] = true
  }

  theNums = nums
  theAvg = avg
  theDp = dp

  return dfs((1 << n) - 1, 0)
}

/*
  s: 位图，代表数组每一位的可用状态，1-可用，0-不可用
  pre: 上一步累加的数
*/
func dfs(s, pre int) bool {
  if s == 0 {
    // 数组每一位都用完
    return true
  }
  if !theDp[s] {
    return false
  }

  theDp[s] = false
  for i, num := range theNums {
    if pre + num > theAvg {
      // 剪枝（数组要升序）
      break
    }
    if (s >> i) & 1 > 0 && dfs(s ^ (1 << i), (pre + num) % theAvg) {
      return true
    }
  }
  return false
}
```

# 划分为 k 个相等的子集 - 状态压缩 + 动态规划
![[Pasted image 20231108113351.png]]

```go
func canPartitionKSubsets(nums []int, k int) bool {
  sum := 0
  for _, num := range nums {
    sum += num
  }
  if sum % k != 0 {
    // 不能整除
    return false
  }
  avg := sum / k
  sort.Ints(nums)
  n := len(nums)
  if nums[n - 1] > avg {
    // 最大数比平均值大
    return false
  }

  // dp[S]: 数组可用状态为i时，是否可以划分为k个相等的子集
  // s: 位图，代表数组每一位的可用状态，1-可用，0-不可用
  dp := make([]bool, 1 << n)
  dp[0] = true
  curSum := make([]int, 1 << n)
  for i, ok := range dp {
    if !ok {
      continue
    }

    for j, num := range nums {
      if num + curSum[i] > avg {
        // 剪枝（数组要升序）
        break
      }
      if (i >> j) & 1 == 0 {
        // nums[j] 没用过
        next := i | (1 << j)
        if !dp[next] {
          curSum[next] = (curSum[i] + num) % avg
          dp[next] = true
        }
      }
    }
  }
  return dp[(1 << n) - 1]
}
```

# 完成所有工作的最短时间
![[Pasted image 20231108150925.png]]

```go
func minimumTimeRequired(jobs []int, k int) int {
	n := len(jobs)
	m := 1 << n
	// sum[j]: j情况下，把工作安排给一个工人，需要的最短时间
	// j: 位图，工作安排情况，0-未被分配，1-已被分配
	sum := make([]int, m)
	for i := 1; i < m; i++ {
		// 当前要安排的工作 index
		x := bits.TrailingZeros(uint(i))
		y := i ^ (1 << x)
		sum[i] = sum[y] + jobs[x]
	}
	// 或
	/*
	for i, v := range jobs {
		for j, bit := 0, 1 << i; j < bit; j++ {
			sum[bit | j] = sum[j] + v
		}
	}
	*/

	// dp[i][j]: 安排i+1个工人，工作安排为j情况下，需要的最短时间
	dp := make([][]int, k)
	for i := range dp {
		dp[i] = make([]int, m)
	}
	for i, s := range sum {
		dp[0][i] = s
	}

	for i := 1; i < k; i++ {
		for j := 0; j < m; j++ {
			minn := math.MaxInt64
			for x := j; x > 0; x = (x - 1) & j {
				// max(dp[i - 1][j - x] 或 max(dp[i - 1][j ^ x] 都行
				minn = min(minn, max(dp[i - 1][j - x], sum[x]))
			}
			dp[i][j] = minn
		}
	}

	return dp[k - 1][m - 1]
}
```

滚动数组
```go
func minimumTimeRequired(jobs []int, k int) int {
  n := len(jobs)
  m := 1 << n
  sum := make([]int, m)
  for i := 1; i < m; i++ {
    x := bits.TrailingZeros(uint(i))
    y := i ^ (1 << x)
    sum[i] = sum[y] + jobs[x]
  }

  dp := make([]int, m)
  copy(dp, sum)
  for i := 1; i < k; i++ {
    for j := m - 1; j > 0; j-- { // 注意这里的顺序
      for x := j; x > 0; x = (x - 1) & j {
        dp[j] = min(dp[j], max(dp[j ^ x], sum[x]))
      }
    }
  }

  return dp[m - 1]
}
```
