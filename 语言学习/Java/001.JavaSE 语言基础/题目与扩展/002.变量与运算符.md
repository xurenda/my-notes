---
date: 2024-01-14 16:03
modified: 2024-01-14 18:24
---

# 企业真题

## 高效的方式计算 `2*8` 的值

>来源：文??辉、轮?科技

使用 `<<`：

```java
2 * 8 == 2 << 3
```

## `&` 和 `&&` 的区别？

>来源：恒?电子、?度

短路性

## Java 中的基本类型有哪些？String 是最基本的数据类型吗？

>来源：恒?电子、?米、贝壳

8 种基本数据类型：

- `byte`
- `short`
- `int`
- `long`
- `float`
- `double`
- `char`
- `boolean`

`String` 不是基本数据类型，属于引用数据类型。

## Java 开发中计算金额时使用什么数据类型？

>来源：5?到家

不能使用 `float` 或 `double`，因为精度不高。

使用 `BigDecimal` 类替换，可以实现任意精度的数据的运算。

## `char` 型变量中能不能存储一个中文汉字，为什么？

>来源：?通快递

基本可以，因为 `char` 使用的是 unicode 字符集，占 2 个字节，包含了世界范围大部分的字符：

```java
char c1 = '中';
char c2 = 'a';
```

但是有些字符超过了 2 个字节，就不能表示了：

```java
char c = '𩷶';
System.out.println(c); // ?
c = '𠮷';
System.out.println(c); // ?
c = '😂';
System.out.println(c); // ?
```

## 代码分析

>来源：君?科技、新?陆

```java
short s1 = 1; 
s1 = s1 + 1;  // 有什么错？= 右边是 int 类型，需要强转
// s1 += 1; // 正确
```

## `int i=0; i=i++;` 执行这两句化后变量 `i` 的值为?

>来源：?软

`0`

```java
i = i++;

// 1. 取右值为 0
// 2. i 自增
// 3. i 赋值为右值（0）
```

## 如何将两个变量的值互换

>来源：北京?彩、中外?译咨询

```java
String s1 = "abc";
String s2 = "123";

String temp = s1;
s1 = s2;
s2 = temp;
```

## `boolean` 占几个字节

>来源：阿??巴

编译时不谈占几个字节。

但是 JVM 在给 `boolean` 类型分配内存空间时，`boolean` 类型的变量占据一个槽位（slot，等于 4 个字节）。

细节：`true`：1；`false`：0

拓展：在内存中，

- `byte`、`short`、`char`、`boolean`、`int`、`float`：占用 1 个 slot
- `double`、`long`：占用 2 个 slot

## 为什么 Java 中 0.1 + 0.2 结果不是 0.3？

>来源：字?跳动

在代码中测试 0.1 + 0.2，你会惊讶的发现，结果不是 0.3，而是 0.3000...4。这是为什么？

几乎所有现代的编程语言都会遇到上述问题，包括 JavaScript、Ruby、Python、Swift 和 Go 等。引发这个问题的原因是，它们都采用了 IEEE 754 标准。

> IEEE 是指“电气与电子工程师协会”，其在 1985 年发布了一个 IEEE 754 计算标准，根据这个标准，小数的二进制表达能够有最大的精度上限提升。但无论如何，物理边界是突破不了的，它仍然不能实现“每一个十进制小数，都对应一个二进制小数”。正因如此，产生了 0.1 + 0.2 不等于 0.3 的问题。

具体的：

整数变为二进制，能够做到“每个十进制整数都有对应的二进制数”，比如数字 3，二进制就是 11；再比如，数字 43 就是二进制 101011，这个毫无争议。

对于小数，并不能做到“每个小数都有对应的二进制数字”。举例来说，二进制小数 0.0001 表示十进制数 0.0625（至于它是如何计算的，不用深究）；二进制小数 0.0010 表示十进制数 0.125；二进制小数 0.0011 表示十进制数 0.1875。看，对于四位的二进制小数，二进制小数虽然是连贯的，但是十进制小数却不是连贯的。比如，你无法用四位二进制小数的形式表示 0.125 ~ 0.1875 之间的十进制小数。

所以在编程中，遇见小数判断相等情况，比如开发银行、交易等系统，可以采用四舍五入或者“同乘同除”等方式进行验证，避免上述问题。

# 拓展练习

## 辨别标识符

- 是否符合规则，即编译是否报错？
- 是否符合规范？即是否够优雅？

以下标识符作为类名是否合适：

```text
class、pubilc、int // 编译报错，是关键字
a、test、ttt、尚硅谷、exercise8 // 编译通过但不规范，“见名知意”、首字母大写、英文
Test、Exercise8 // 合适
```

以下标识符作为变量名是否合适：

```text
class、int、a++、--a、4#R、#44、1b // 编译报错，关键字、不符合标识符要求
Test、a1、b0a、尚硅谷、$4 // 编译通过但不规范，“见名知意”、小驼峰、英文
miles、radius、apps、x、y // 合适
```

## 数据类型转换简答

```java
// 1. 判断如下代码是否编译通过，如果能，结果是多少？
short s1 = 120;
short s2 = 8;
short s3 = s1 + s2;
// 编译不通过，因为 s1+s2 自动提升为 int 类型

// 2. 判断如下代码是否编译通过，如果能，结果是多少？
short b1 = 120;
short b2 = 8;
byte b3 = (byte) (b1 + b2);
// 编译通过，结果是 -128（溢出）

// 3. 判断如下代码是否编译通过，如果能，结果是多少？
char c1 = '0';
char c2 = '1';
char c3 = c1 + c2;
// 编译不通过，因为 c1+c2 自动提升为 int 类型

// 4. 判断如下代码是否编译通过，如果能，结果是多少？
char c1 = '0';
char c2 = '1';
System.out.println(c1 + c2);
// 编译通过，println 方法可以接收各种数据类型的值（这里是 int），进行输出，结果是 97

// 5. 判断如下代码是否编译通过，如果能，结果是多少？
int i = 4;
long j = 120;  // 自动类型提升
double d = 34; // 自动类型提升
float f = 1.2;
System.out.println(i + j + d + f);
// 编译不通过，因为 1.2 默认是 double 类型，不能直接赋值给 float 的 f，
// 要么在 1.2 加 F，要么加 (float) 1.2

// 6. 判断如下代码是否编译通过，如果能，结果是多少？
int a = 1;
int b = 2;
double result = a / b;
System.out.println(result);
// 编译通过，结果是 0.0，
// 先计算 a / b 结果是0，然后提升到 double
```

## 判断如下代码的运行结果

```java
int i = 1;
int j = i++; // j = 1, i = 2
int k = i++ * ++j + ++i * j++;
// 2 * 2          + 4 * 2 = 12
// i = 3, j = 2     i = 4, j = 3

System.out.println("i = " + i); // 4
System.out.println("j = " + j); // 3
System.out.println("k = " + k); // 12
```

## 判断如下程序的运行结果

```java
int i = 1;
i *= 0.2; // 0
i++; // 1
System.out.println("i=" + i); // 1
```

## 判断如下程序的运行结果

```java
int i = 2;
i *= i++; // 4
// 1. 先取 i 的值，放到操作数栈中：2 * 2
// 2. i 自增，i=3
// 3. 用操作数栈赋值：4

int j = 2;
j *= j + 1; // 2 * 3 = 6

int k = 2;
k *= ++k; // 6
// 1. 放到操作数栈中：2 * ?
// 2. k 自增，k=3
// 3. 操作数栈中：2 * 3

System.out.println("i=" + i); // 4
System.out.println("j=" + j); // 6
System.out.println("k=" + k); // 6
```

## 语法判断

```java
float f = 3.4; // 错误，因为 3.4 默认是 double 类型

System.out.println(15 / 2 * 2); // 14，因为 15 / 2 结果是 7
```

## 说明基本数据类型变量之间自动类型提升的运算规则

- 容量小的类型自动转换为容量大的数据类型
- 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。
- `byte`、`short`、`char` 之间不会相互转换，他们三者在计算时首先转换为 `int` 类型。 
- `boolean` 类型不能与其它数据类型运算。

## 说明基本数据类型变量之间强制类型转换的使用规则和可能的问题

强制类型转换：自动类型转换的逆运算，需要使用强制类型转换符 `()`

注意的问题：可能会造成精度的损失
