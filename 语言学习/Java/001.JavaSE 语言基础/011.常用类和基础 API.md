---
date: 2024-01-09 20:55
modified: 2024-01-09 22:58
---

# 字符串相关类之不可变字符序列：`String`

## `String` 的特性

`java.lang.String` 类代表字符串。Java 程序中所有的字符串文字（例如 `"hello"`）都可以看作是实现此类的实例。

字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。

字符串 `String` 类型本身是 `final` 声明的，意味着我们不能继承 `String`。

`String` 对象的字符内容是存储在一个字符数组 `value[]` 中的。`"abc"` 等效于 `char[] data = {'h', 'e', 'l', 'l', 'o'}`。

![[image-20220514184404024.png]]

```java
// jdk8 中的 String 源码：
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[]; // String 对象的字符内容是存储在此数组中
 
    /** Cache the hash code for the string */
    private int hash; // Default to 0
```

- `private` 意味着外面无法直接获取字符数组，而且 `String` 没有提供 `value` 的 getter 和 setter 方法
- `final` 意味着字符数组的引用不可改变，而且 `String` 也没有提供方法来修改 `value` 数组某个元素值
- 因此字符串的字符数组内容也不可变的，即 `String` 代表着不可变的字符序列。即，一旦对字符串进行修改，就会产生新对象。
- JDK9：底层变成 `byte[]` 数组。

```java
// JDK9 底层数组变成 byte[]
public final class String implements java.io.Serializable, Comparable<String>, CharSequence { 
    @Stable
    private final byte[] value;
}

//官方说明：... that most String objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal char arrays of such String objects is going unused.

//细节：... The new String class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.
```

Java 语言提供对字符串串联符号（"`+`"）以及将其他对象转换为字符串的特殊支持（`toString()` 方法）

## `String` 的内存结构

### 概述

因为字符串对象设计为不可变，那么所以字符串有常量池来保存很多常量对象。

JDK6 中，字符串常量池在方法区。JDK7 开始，就移到堆空间，直到目前 JDK17 版本。

举例内存结构分配：

![[1562945799274.png]]

### 字面量

```java
String s1 = "hello";
String s2 = "hello";
System.out.println(s1 == s2);
// 内存中只有一个 "hello" 对象被创建，同时被 s1 和 s2 共享
```

对应内存结构为：（以下内存结构以 JDK6 为例绘制）

![[image-20220405152839525.png]]

![[image-20220405152941599.png]]

```java
Person p1 = new Person();
p1.name = "Tom";

Person p2 = new Person();
p2.name = "Tom";

System.out.println(p1.name.equals(p2.name)); // true
System.out.println(p1.name == p2.name); // true
System.out.println(p1.name == "Tom"); // true
```

![[image-20220405153027693.png]]

### `new`

`String str1 = "abc";` 与 `String str2 = new String("abc");` 的区别？

![[image-20220405160149200.png]]

`str2` 首先指向堆中的一个字符串对象，然后堆中字符串的 `value` 数组指向常量池中常量对象的 `value` 数组。

- 字符串常量存储在字符串常量池，目的是共享。
- 字符串非常量对象存储在堆中。

练习：

```java
String s1 = "javaEE";
String s2 = "javaEE";
String s3 = new String("javaEE");
String s4 = new String("javaEE");

System.out.println(s1 == s2); // true
System.out.println(s1 == s3); // false
System.out.println(s1 == s4); // false
System.out.println(s3 == s4); // false
```

![[image-20220405160321172.png]]

题目：`String str2 = new String("hello");` 在内存中创建了几个对象？

答：2 个，一个堆中的 `String` 对象，一个字符串常量池中的 `"hello"` 字符串常量

### `+` 和 `intern()`

`String s1 = "a";`

说明：在字符串常量池中创建了一个字面量为 `"a"` 的字符串。

`s1 = s1 + "b";`

说明：从指向原来的 `"a"` 字符串常量池对象，变成在堆空间中产生了一个字符串 `"ab"`。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。

`String s2 = "ab";`

说明：直接在字符串常量池中创建一个字面量为 `"ab"` 的字符串。

`String s3 = "a" + "b";`

说明：`s3` 指向字符串常量池中已经创建的 `"ab"` 的字符串。

`String s4 = s1.intern();`

说明：堆空间的 `s1` 对象在调用 `intern()` 之后，会将常量池中已经存在的 `"ab"` 字符串赋值给 `s4`

结论：

1. 常量 + 常量（或字面量）：结果是常量池。且常量池中不会存在相同内容的常量。因为编译期间就可以确定
2. 常量与变量或变量与变量：结果在堆中
3. 拼接后调用 `intern` 方法：返回值在常量池中
4. `concat` 方法拼接，哪怕是两个常量对象拼接，结果也是在堆

## `String` 的常用 API

说明：`xx` 代表有多个重载方法

### 构造器

```java
public String() // 初始化新创建的 String 对象，以使其表示空字符序列

String(String original)
// 初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列；
// 换句话说，新创建的字符串是该参数字符串的副本。

public String(char[] value) // 通过当前参数中的字符数组来构造新的 String

public String(char[] value, int offset, int count) // 通过字符数组的一部分来构造新的 String

public String(byte[] bytes) // 通过使用平台的默认字符集解码当前参数中的字节数组来构造新的 String

public String(byte[] bytes, String charsetName)
// 通过使用指定的字符集解码当前参数中的字节数组来构造新的 String
```

### `String` 与其他结构间的转换

字符串 -> 基本数据类型、包装类：

- `Integer` 包装类的 `public static int parseInt(String s)` 可以将由“数字”字符组成的字符串转换为整型
- 类似地，使用 `java.lang` 包中的 `Byte`、`Short`、`Long`、`Float`、`Double` 类调相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型

基本数据类型、包装类 -> 字符串：

- 调用 `String` 类的 `public String valueOf(int n)` 可将 `int` 型转换为字符串
- 相应的 `valueOf(byte b)`、`valueOf(long l)`、`valueOf(float f)`、`valueOf(double d)`、`valueOf(boolean b)` 可由参数的相应类型到字符串的转换

字符数组 -> 字符串：

- `String` 类的构造器 `String(char[])` 和 `String(char[]，int offset，int length)` 分别用字符数组中的全部字符和部分字符创建字符串对象

字符串 -> 字符数组：

- `public char[] toCharArray()`：将字符串中的全部字符存放在一个字符数组中的方法
- `public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)`：提供了将指定索引范围内的字符串存放到数组中的方法

字符串 -> 字节数组：（编码）

- `public byte[] getBytes()`：使用平台的默认字符集将此 `String` 编码为 `byte` 序列，并将结果存储到一个新的 `byte` 数组中
- `public byte[] getBytes(String charsetName)`：使用指定的字符集将此 `String` 编码到 `byte` 序列，并将结果存储到新的 `byte` 数组

字节数组 -> 字符串：（解码）

- `String(byte[])`：通过使用平台的默认字符集解码指定的 `byte` 数组，构造一个新的 `String`
- `String(byte[]，int offset，int length)`：用指定的字节数组的一部分，即从数组起始位置 `offset` 开始取 `length` 个字节构造一个字符串对象
- `String(byte[], String charsetName)` 或 `new String(byte[], int, int, String charsetName)`：解码，按照指定的编码方式进行解码

代码示例：

```java
@Test
public void test01() throws Exception {
    String str = "中国";
    System.out.println(str.getBytes("ISO8859-1").length); // 2
    // ISO8859-1 把所有的字符都当做一个 byte 处理，处理不了多个字节
    System.out.println(str.getBytes("GBK").length); // 4 每一个中文都是对应 2 个字节
    System.out.println(str.getBytes("UTF-8").length); // 6 常规的中文都是 3 个字节

    /*
     * 不乱码：1. 保证编码与解码的字符集名称一样 2. 不缺字节
     */
    System.out.println(new String(str.getBytes("ISO8859-1"), "ISO8859-1")); // 乱码
    System.out.println(new String(str.getBytes("GBK"), "GBK")); // 中国
    System.out.println(new String(str.getBytes("UTF-8"), "UTF-8")); // 中国
}
```

### 常用方法

```java
boolean isEmpty() // 字符串是否为空

int length() // 返回字符串的长度，字符数

String concat(xx) // 拼接

boolean equals(Object obj) // 比较字符串是否相等，区分大小写

boolean equalsIgnoreCase(Object obj) // 比较字符串是否相等，不区分大小写

int compareTo(String other) // 比较字符串大小，区分大小写，按照 Unicode 编码值比较大小（字典序）

int compareToIgnoreCase(String other) // 比较字符串大小，不区分大小写

String toLowerCase() // 将字符串中大写字母转为小写

String toUpperCase() // 将字符串中小写字母转为大写

String trim() // 去掉字符串前后空白符

public String intern() // 结果在常量池中共享
```

### 查找

```java
boolean contains(xx) // 是否包含 xx

int indexOf(xx)
// 从前往后找当前字符串中 xx，如果有返回第一次出现的下标，要是没有返回 -1

int indexOf(String str, int fromIndex)
// 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始找

int lastIndexOf(xx) // 从后往前找

int lastIndexOf(String str, int fromIndex)：// 从后往前找，从最后找到指定位置止
```

### 字符串截取

```java
String substring(int beginIndex)
// 返回一个新的字符串，它是此字符串的从 beginIndex 开始截取到最后的一个子字符串

String substring(int beginIndex, int endIndex)
// 返回一个新字符串，它是此字符串从 beginIndex 开始截取到 endIndex（不包含）的一个子字符串
// 包头不包尾
```

### 和字符/字符数组相关

```java
char charAt(index) // 返回 [index] 位置的字符

char[] toCharArray() // 将此字符串转换为一个新的字符数组返回

static String valueOf(char[] data) // 返回指定数组中表示该字符序列的 String

static String valueOf(char[] data, int offset, int count)
// 返回指定数组中表示该字符序列的 String

static String copyValueOf(char[] data) // 返回指定数组中表示该字符序列的 String

static String copyValueOf(char[] data, int offset, int count)
// 返回指定数组中表示该字符序列的 String
```

### 开头与结尾

```java
boolean startsWith(xx) // 测试此字符串是否以指定的前缀开始

boolean startsWith(String prefix, int toffset)
// 测试此字符串从指定索引开始的子字符串是否以指定前缀开始

boolean endsWith(xx) // 测试此字符串是否以指定的后缀结束
```

### 替换

```java
String replace(char oldChar, char newChar)
// 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的
// 不支持正则

String replace(CharSequence target, CharSequence replacement)
// 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串

String replaceAll(String regex, String replacement)
// 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串

String replaceFirst(String regex, String replacement)
// 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串
```

相比之下：JavaScript 的正则字面量太好用了、太优雅了

# 字符串相关类之可变字符序列：`StringBuffer`、`StringBuilder`

因为 `String` 对象是不可变对象，虽然可以共享常量对象，但是对于频繁字符串的修改和拼接操作，效率极低，空间消耗也比较高。因此，JDK 又在 `java.lang` 包提供了可变字符序列 `StringBuffer` 和 `StringBuilder` 类型。

## `StringBuffer` 与 `StringBuilder` 的理解

`java.lang.StringBuffer` 代表==可变的字符序列==，JDK1.0 中声明，可以对字符串内容进行增删，此时不会产生新的对象。比如：

```java
// 情况 1：
String s = new String("我喜欢学习");

// 情况 2：
StringBuffer buffer = new StringBuffer("我喜欢学习");
buffer.append("数学");
```

![[image-20220405221714261.png]]

原理：底层是一个可变长字符数组

![[image-20220228153030902.png]]

![[image-20220405174414780.png]]

继承结构：

![[image-20220405174233055.png]]

`StringBuilder` 和 `StringBuffer` 非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样。

区分 `String`、`StringBuffer`、`StringBuilder`

- `String`：不可变的字符序列； 底层使用 `char[]` 数组存储
- `StringBuffer`：可变的字符序列；线程安全（方法有 `synchronized` 修饰），效率低；底层使用 `char[]` 数组存储
- `StringBuilder`：可变的字符序列； JDK1.5 引入，线程不安全的，效率高；底层使用 `char[]` 数组存储
- JDK9 以前：底层使用 `char[]`；JDK9 以后：底层使用 `byte[]`

## `StringBuilder`、`StringBuffer` 的 API

`StringBuilder`、`StringBuffer` 的 API 是完全一致的，并且很多方法与 `String` 相同。

```java
StringBuffer append(xx) // 提供了很多的 append() 方法，用于进行字符串追加的方式拼接

StringBuffer delete(int start, int end) // 删除 [start, end) 之间字符

StringBuffer deleteCharAt(int index) // 删除 [index] 位置字符

StringBuffer replace(int start, int end, String str)
// 替换 [start, end) 范围的字符序列为 str

void setCharAt(int index, char c) // 替换 [index] 位置字符

char charAt(int index) // 查找指定 [index] 位置上的字符

StringBuffer insert(int index, xx) // 在 [index] 位置插入 xx

int length() // 返回存储的字符数据的长度

StringBuffer reverse() // 反转

int indexOf(String str) // 在当前字符序列中查询 str 的第一次出现下标，没有返回 -1

int indexOf(String str, int fromIndex)

int lastIndexOf(String str)

int lastIndexOf(String str, int fromIndex)

String substring(int start) // 截取当前字符序列 [start, 最后]

String substring(int start, int end) // 截取当前字符序列 [start, end)

String toString() // 返回此序列中数据的字符串表示形式

void setLength(int newLength) // 设置当前字符序列长度为 newLength
```

## 效率测试

```java
// 初始设置
long startTime = 0L;
long endTime = 0L;
String text = "";
StringBuffer buffer = new StringBuffer("");
StringBuilder builder = new StringBuilder("");

// 开始对比
startTime = System.currentTimeMillis();
for (int i = 0; i < 20000; i++) {
    buffer.append(String.valueOf(i));
}
endTime = System.currentTimeMillis();
System.out.println("StringBuffer 的执行时间：" + (endTime - startTime));

startTime = System.currentTimeMillis();
for (int i = 0; i < 20000; i++) {
    builder.append(String.valueOf(i));
}
endTime = System.currentTimeMillis();
System.out.println("StringBuilder 的执行时间：" + (endTime - startTime));

startTime = System.currentTimeMillis();
for (int i = 0; i < 20000; i++) {
    text = text + i;
}
endTime = System.currentTimeMillis();
System.out.println("String 的执行时间：" + (endTime - startTime));
```

```text
StringBuffer 的执行时间：118  
StringBuilder 的执行时间：119  
String 的执行时间：309
```

## 题目

```java
String str = null;
StringBuffer sb = new StringBuffer();
sb.append(str);

System.out.println(sb.length()); // 4
System.out.println(sb); // "null"

StringBuffer sb1 = new StringBuffer(str);
System.out.println(sb1); // Exception Cannot invoke "String.length()" because "str" is null
```

# JDK8 之前：日期时间 API

## `java.lang.System` 类的方法

`System` 类提供的 `public static long currentTimeMillis()`：用来返回当前时间与 1970 年 1 月 1 日 0 时 0 分 0 秒之间以毫秒为单位的时间差——时间戳
 
计算世界时间的主要标准有：

- UTC(Coordinated Universal Time)
- GMT(Greenwich Mean Time)
- CST(Central Standard Time)

在国际无线电通信场合，为了统一起见，使用一个统一的时间，称为通用协调时（UTC, Universal Time Coordinated）。UTC 与格林尼治平均时（GMT, Greenwich Mean Time）一样，都与英国伦敦的本地时相同。这里，UTC 与 GMT 含义完全相同。

## `java.util.Date`

表示特定的瞬间，精确到毫秒。

构造器：

- `Date()`：使用无参构造器创建的对象可以获取本地当前时间
- `Date(long 时间戳)`：把该毫秒值换算成日期时间对象

常用方法：

- `getTime()`: 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 `Date` 对象表示的毫秒数
- `toString()`: 把此 `Date` 对象转换为以下形式的 `String`
	- `dow mon dd hh:mm:ss zzz yyyy`，其中： `dow` 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，`zzz` 是时间标准。
- 其它很多方法都过时了。

## `java.text.SimpleDateFormat`

`java.text.SimpleDateFormat` 类是一个不与语言环境有关的方式来格式化和解析日期的具体类。

- 可以进行格式化：`日期 -> 文本`
- 可以进行解析：`文本 -> 日期`

构造器：

- `SimpleDateFormat()`：默认的模式和语言环境创建对象
- `SimpleDateFormat(String pattern)`：该构造方法可以用参数 `pattern` 指定的格式创建一个对象

格式化：

- `public String format(Date date)`：格式化时间对象 `date`

解析：

- `public Date parse(String source)`：从给定字符串的开始解析文本，以生成一个日期

![[1572599023197.png]]

## `java.util.Calendar`（日历）

![[image-20220511105252261.png]]

`Date` 类的 API 大部分被废弃了，替换为 `Calendar`

`Calendar` 类是一个抽象类，主用用于完成日期字段之间相互操作的功能。

获取 `Calendar` 实例的方法：

- 使用 `Calendar.getInstance()` 方法 ![[image-20220123184906903.png]]
- 调用它的子类 `GregorianCalendar`（公历）的构造器![[image-20220405225828816.png]]

一个 `Calendar` 的实例是系统时间的抽象表示，可以修改或获取 `YEAR`、`MONTH`、`DAY_OF_WEEK`、`HOUR_OF_DAY`、`MINUTE`、`SECOND` 等日历字段对应的时间值。

- `public int get(int field)`：返回给定日历字段的值
- `public void set(int field, int value)`：将给定的日历字段设置为指定的值
- `public void add(int field, int amount)`：根据日历的规则，为给定的日历字段添加或者减去指定的时间量
- `public final Date getTime()`：将 `Calendar` 转成 `Date` 对象
- `public final void setTime(Date date)`：使用指定的 `Date` 对象重置 `Calendar` 的时间

常用字段：

| 字段值 | 含义 |
| ---- | ---- |
| `YEAR` | 年 |
| `MONTH` | 月（从 0 开始） |
| `DAY_OF_MONTH` | 月中的天（几号） |
| `HOUR` | 时（12 小时制） |
| `HOUR_OF_DAY` | 时（24 小时制） |
| `MINUTE` | 分 |
| `SECOND` | 秒 |
| `DAY_OF_WEEK` | 周中的天（星期几，周日为 1） |

- 月份：一月是 0、二月是 1、……、十二月是 11
- 星期：周日是 1、周一是 2 、……、周六是 7

# JDK8：新的日期时间 API

如果我们可以跟别人说：“我们在 `1502643933071` 见面，别晚了！”那么就再简单不过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0 中包含了一个 `java.util.Date` 类，但是它的大多数方法已经在 JDK 1.1 引入 `Calendar` 类之后被弃用了。而 `Calendar` 并不比 `Date` 好多少。它们面临的问题是：

- 可变性：像日期和时间这样的类应该是不可变的。
- 偏移性：`Date` 中的年份是从 1900 开始的，而月份都从 0 开始。
- 格式化：格式化只对 `Date` 有用，`Calendar` 则不行。
- 此外，它们也不是线程安全的；不能处理闰秒等。

>闰秒，是指为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中（也可能在季末）对协调世界时增加或减少 1 秒的调整。由于地球自转的不均匀性和长期变慢性（主要由潮汐摩擦引起的），会使世界时（民用时）和原子时之间相差超过到 ±0.9 秒时，就把协调世界时向前拨 1 秒（负闰秒，最后一分钟为 59 秒）或向后拨 1 秒（正闰秒，最后一分钟为 61 秒）；闰秒一般加在公历年末或公历六月末。
>
>目前，全球已经进行了 27 次闰秒，均为正闰秒。

综上：对日期和时间的操作一直是 Java 程序员最痛苦的地方之一。

第三次引入的 API 是成功的，并且 Java 8 中引入的 `java.time` API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。

Java 8 以一个新的开始为 Java 创建优秀的 API。新的日期时间 API 包含：

- `java.time`：包含值对象的基础包
- `java.time.chrono`：提供对不同的日历系统的访问
- `java.time.format`：格式化和解析时间和日期
- `java.time.temporal`：包括底层框架和扩展特性
- `java.time.zone`：包含时区支持的类

说明：新的 `java.time` 中包含了所有关于时钟（`Clock`）、本地日期（`LocalDate`）、本地时间（`LocalTime`）、本地日期时间（`LocalDateTime`）、时区（`ZonedDateTime`）和持续时间（`Duration`）的类。

尽管有 68 个新的公开类型，但是大多数开发者只会用到基础包和 `format` 包，大概占总数的三分之一。

## 本地日期时间：`LocalDate`、`LocalTime`、`LocalDateTime`

| 方法 | **描述** |
| ---- | ---- |
| `now()` / `now(ZoneId zone)` | 静态方法，根据当前时间创建对象/指定时区的对象 |
| `of(xx, xx, xx, xx, xx, xxx)` | 静态方法，根据指定日期/时间创建对象 |
| `getDayOfMonth()`  | 获得月份天数（1-31） |
| `getDayOfYear()` | 获得年份天数（1-366） |
| `getDayOfWeek()` | 获得星期几（返回一个 `DayOfWeek` 枚举值） |
| `getMonth()` | 获得月份, 返回一个 `Month` 枚举值 |
| `getMonthValue()`  | 获得月份（1-12） |
| `getYear()` | 获得年份 |
| `getHours()` / `getMinute()` / `getSecond()` | 获得当前对象对应的时、分、秒 |
| `withDayOfMonth()` / `withDayOfYear()` / `withMonth()` / `withYear()` | 将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象 |
| `with(TemporalAdjuster t)` | 将当前日期时间设置为校对器指定的日期时间 |
| `plusDays()` / `plusWeeks()` / `plusMonths()` / `plusYears()` /`plusHours()`)) | 向当前对象添加几天、几周、几个月、几年、几小时 |
| `minusMonths()` / `minusWeeks()` / `minusDays()` / `minusYears()` / `minusHours()` | 从当前对象减去几月、几周、几天、几年、几小时 |
| `plus(TemporalAmount t)` / `minus(TemporalAmount t)` | 添加或减少一个 `Duration` 或 `Period` |
| `isBefore()` / `isAfter()` | 比较两个 `LocalDate` |
| `isLeapYear()` | 判断是否是闰年（在 `LocalDate` 类中声明）） |
| `format(DateTimeFormatter t)` | 格式化本地日期、时间，返回一个字符串 |
| `parse(Charsequence text)` | 将指定格式的字符串解析为日期、时间 |
